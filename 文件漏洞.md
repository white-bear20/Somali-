# 文件漏洞学习笔记

<h2 id="enum">目录</h2>

* ### [什么是文件上传漏洞?](#1)
* ### [利用方式](#2)
* ### [绕过方法](#3)
* ### [防御手段](#4)
* ### [文件包含](#5)

***

> <h2 id="1">什么是文件上传漏洞?</h2>
    通过某种手段可以将恶意文件上传到目标主机，并且进行执行的就是文件上传漏洞

> <h2 id="2">利用方式</h2>
    常见的利用方式是通过上传点上传一句话木马，然后利用webshell工具去连接，或者直接传大马，通过这些东西去对目标系统进行操作，关于利用方式有很多，其实这只是一种控制目标系统的方法而已，只要能进入目标系统，那就是后渗透阶段

> <h2 id="3">绕过方法</h2>

### JS前端验证
    查看有没有前端验证的方法很简单，打开bp，设置好代理，如果点击上传发现拦截却没有包，就说明就是前端验证
    这种验证最好解决，直接bp在抓包时删除所有JS代码，或者用F12删除里面关键的JS代码，或者浏览器直接禁用JS
### 上传文件被加密
    对上传的文件内容进行加密，这时候就想办法把上传后的文件（被加密过的文件给down下来，看看和未加密的有什么区别），并且直接在被加密的文件中插入一句话，并且重新上传试试看。
### 上传点被隐藏
    知道有上传，但是上传点被隐藏了，例如说不知道上传参数，那么可以使用字典fuzzing一下，或者查看一下JS文件，看看会不会有什么信息
### MIME绕过
    更改HTTP中的Content-Type:属性为允许的类型，例如image/jpeg
### 条件竞争
### 文件内容检测绕过
    图片马
    添加文件头
    添加文件尾
### 文件扩展名绕过
    使用一些其他会被解析的文件名，例如APS的cer,asa
### 特殊文件名绕过
    根据windows的特性，可以往文件中添加一些windows不允许出现在文件名中的字符，例如空格，
    文件名最后面有个.的话上传到windows中会自动删除
### 00截断
### .htaccess解析漏洞
    上传一个.htaccess文件，里面内容为
    AddType    application/x-httpd-php    .jpg
    表示jpg文件也作为php执行，但是这个漏洞只针对apache而且可以通过设置使这种文件不生效
### apache解析漏洞
    1.一个文件名为test.x1.x2.x3的文件，apache会从x3的位置开始尝试解析，如果x3不属于apache能够解析的扩展名，那么apache会尝试去解析x2，直到能够解析到能够解析的为止，否则就会报错。
    2.CVE-2017-15715，这个漏洞利用方式就是上传一个文件名最后带有换行符(只能是\x0A，如上传a.php，然后在burp中修改文件名为a.php\x0A)，以此来绕过一些黑名单过滤。
### IIS解析漏洞
    IIS6.0在解析asp格式的时候有两个解析漏洞，一个是如果目录名包含".asp"字符串，
    那么这个目录下所有的文件都会按照asp去解析，另一个是只要文件名中含有".asp;"
    会优先按asp来解析
    IIS7.0/7.5是对php解析时有一个类似于Nginx的解析漏洞，对任意文件名只要在URL
    后面追加上字符串"/任意文件名.php"就会按照php的方式去解析；
### Nginx解析漏洞
    解析：(任意文件名)/(任意文件名).php | (任意文件名)%00.php
    描述：目前Nginx主要有这两种漏洞，一个是对任意文件名，在后面添加/任意文件名.php
    的解析漏洞，比如原本文件名是test.jpg，可以添加为test.jpg/x.php进行解析攻击。
    还有一种是对低版本的Nginx可以在任意文件名后面添加%00.php进行解析攻击。
### 解析漏洞
    Content-Disposition: form-data; name="file";  filename=php.php;.jpg
### ::$DATA绕过
    在windows中，如果文件名后缀有::$DATA的话那么它就会被当作windows流文件，可以做到绕过检测，并且会保存文件的原有名字
### WAF绕过
    Content-Disposition: form-data; name="file"; filename="a.php"   

    1.对文件内容，数据或者数据包进行处理
        Content-Disposition: ~form-data; name="file"; filename="a.php" 
        Content-Disposition: *; name="file"; filename="a.php" 
    2.大小写混写
        content-Disposition: Form-data; name="file"; filename="a.php"   
    3.通过删减空格
        Content-Disposition:   form-data;name="file";   filename="a.php"   
    4.通过字符串拼接绕过
        Content-Disposition: f+orm-data; name="file"; filename="a.php"
    5.双文件上传绕过

> <h2 id="4">防御手段</h2>
    1.设置白名单
    2.对上传目录的文件夹里面的文件不做执行
    3.禁止翻出目录
    4.对目录的权限做设置
    5.对文件名采用随机命名
    6.对文件进行二次渲染

> <h2 id="5">文件包含</h2>
`其实本来文件包含是单独开一个板块的，但是我觉得内容又不多，那就写一起吧，况且文件包含多数也会配合文件上传使用`
    JSP文件包含
	JSP文件包含函数:
		java.io.file()
		java.io.filereader()
		静动态包含include
	静态包含
		<?@ include file="1.jsp"?>
	动态包含
		<%String name = request.getParameter("name"); %>
		<jsp:include page="<%=name%>"/>
	注:
		静态包含是不支持赋值变量的，只能包含指定的文本文件
		动态包含仅支持包含WEB路径下的JSP文件
ASPX文件包含
	ASPX文件包含函数
		include file
		include virtual
	静态包含
		<!--#include file="tos.aspx"-->
		<!--#include virtual="header.inc"-->
	注:
		aspx不支持动态包含,asp一样不支持动态包含
		任意目录任意文件可以被包含，可以把内容当作aspx代码执行
PHP文件包含
	PHP文件包含函数
		include()
		include_once()
		require()
		require_once()
		fopen()
		readfile()
	include和require的区别，include包含一个不存在的文件时，会报错，但是下面的语句会正常执行，而require会报错并且不向下执行
	include_once和require_once都是之前包含过的文件就不会在包含了
	fopen返回一个文件指针
	readfile读取一个文件到缓冲区，返回一个整数


文件包含，伪协议利用
	file伪协议 //需要文件的绝对路径
		?f=file:///var/www/html/index.php
	
	php伪协议 //分input和filter
		input 需要allow_url_include为On,他会将POST数据当PHP代码执行
			?f=php://input //在POST数据中写上 <?php phpinfo();?>

		filter
			?f=php://filter/resource=file:///var/www/html/index.php
			读取源码
			?f=php://filter/convert.base64-encode/resource=./index.php
	
	zip伪协议	 //可以直接包含到zip中的文件
			?f=zip:///var/www/html/a.zip/a.txt
	
	phar伪协议//和zip类似

	data伪协议 //allow_url_include:On allow_url_fopen:On
			?f=data://text/plain,<?php phpinfo(); ?>	//直接执行php代码
	
	http伪协议 //allow_url_include:On allow_url_fopen:On
			这就是远程文件包含了，不过注意，不要让文件被二次解析，不然可能会包含失败
***
[回到顶部](#enum)