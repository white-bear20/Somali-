# CCNA网络基础知识学习
*内容来源于《CCNA学习指南中文版》,因为这本书里面的知识都很基础，故可以作为基础知识，在这里可能会更注重于一些实践的东西，而不是纯理论*

<h2 id="menu">目录</h2>

* ### [网络模型](#1)
* ### [OSI七层模型](#2)
* ### [数据封装](#3)
* ### [Cisco3层分层模型](#4)
* ### [进制转换](#5)
* ### [TCP/IP简介](#6)
***

> <h2 id="1">网络模型</h2>
### 最早的简单网络
    主机通过集线器互连
#### 集线器
    关于集线器这种网络设置，可以理解它为一个扩展接口，例如我们电脑只有一个有线网卡，那么理论上，我们只能连接一台主机，但是集线器上可能有很多接口，那么我们都把网线插到集线器上，那么我们就相当于连接了插入其他接口的主机，这就形成了一个网络。

    集线器工作在第二层，所以是只能在局域网使用，并且这个网络中会有一个冲突域和一个广播域
![alt 集线器](./img/集线器.png)
#### 冲突域
    这里先简单说一下什么是冲突域，等到后面有写广播以及ARP的时候或许更能理解，在内网中使用的广播通信，那么在同一时间是只能发送一条信息的，假设两个主机同时发出了一条信息，那么就会产生冲突，结果就是导致谁也发不了信息，这就是冲突域，而且一个网络中的主机越多，冲突域也就越大，发送冲突的可能性也就越高，当然这是有解决方法的，有可以划分冲突域的网络设备
#### 广播域
    二层通信用的就是广播，所谓的广播域就是一个局域网的通信范围，例如这个局域网有30台主机，那么这30台主机就处在一个广播域，也就是说只要在这个网络中发送广播包，它们都能收到，广播域也有网络设备能划分（三层网络设备）
#### 通信过程
    我的IP(192.168.0.2)
    东哥IP(192.168.0.3)
    我现在想和东哥通信，那么我首先要做的是要获取东哥的MAC地址(因为内网通信用的不是IP，而是MAC地址)
        1.发送广播包(广播的IP是192.168.0.255,MAC是ff:ff:ff:ff:ff:ff,IP可能是随着网段不同会变化，但是MAC是固定的)，内容为192.168.0.3是谁
        2.在这个网络每台设备都会接到这个广播包，然后进行对比，当东哥接到这个广播包后，发现是在找自己，他就会回应这个包(向192.168.0.2发送自己的MAC地址)
        3.我收到它的回应之后就有了它的MAC地址了，这样我们就能通过MAC进行通信了
        4.注意：在我获取到东哥的IP和MAC的时候，东哥也拥有了我的IP和MAC
### 划分一个新的网络
    通过集线器组成的网络我们可以知道，效率是非常低的，而且主机越多效率越低(因为冲突的存在),我们可以通过其他网络设备去划分网络(网络分段)，例如 路由器，交换机，网桥(早就不用了)，
    在继续之前我想先列出一下，在局域网中通信出现网络阻塞的原因
        1.广播域中有太多主机
        2.广播风暴
        3.组播
        4.低带宽
        5.使用了集线器
#### 使用交换机进行网络分段
    交换机这种设备也多用于局域网，进行二层通信(除非是三层交换机),它可以对冲突域进行划分，但是不划分广播域,从下图可以看到,使用交换机划分出了两个冲突域(交换机每个接口都是一个冲突域)，但是广播域就一个
    如果这个网络中的主机很多的话，那么就很容易形成网络堵塞。
![alt 交换机](./img/交换机.png)
### 互联网最小模型
    在这个网络模型中我们将使用路由器(三层设备),在因特网的网络互连中最常见的就是路由器，它的功能非常多(例如路由选址，端口转发),而使用路由器可以对广播域和冲突域进行划分，我对于局域网的理解为一个广播域就是一个局域网，那么划分了多个广播域的话就是多个局域网，这多个局域网之间通信就已经是在跨网段通信了，而因特网也是这样从小成多的连接组成的，所以我说这是互联网的最小模型。
![alt 路由器](./img/路由器.png)

> <h2 id="2">OSI七层模型</h2>
### OSI七层模型简介
    应用层(文件，打印，消息，数据库，应用服务)
    表示层(数据加密，压缩，转换)
    会话层(会话控制)
    传输层(端到端连接)
    网络层(路由选择)
    数据链路层(组帧)
    物理层(物理拓扑)
### 应用层
    应用层是用户与计算机进行实际通信的地方，实际上只有当马上要访问的网络的时候才会用到这一层，最简单的例子是使用浏览器查看本地文档时，这是与网络无关的，但是当我们要使用HTTP协议去请求文档，或者使用FTP进行下载的时候，就需要应用层来协助了，网络通信是软件的一部分，这点很重要，软件可以有很多功能，网络通信只是它的功能之一，

    应用层还负责识别并建立想要通信的计算机一方的可用性，并决定想要的通信是否存在足够的资源。
    应用层是实际应用程序之间的接口。
### 表示层
    表示层为应用层提供数据，并负责数据转换和代码格式化，这层就像一个翻译器
### 会话层
    会话层负责建立，管理和终止表示层实体之间的会话连接，这一层也在设备或节点之间提供会话控制，它在系统之间协调通信过程，提供三种不同的组织方式:
        单工
        半双工
        全双工
### 传输层
    传输层将数据分段并重组为数据流，传输层所提供的服务用于来自上层应用程序的数据进行分段和重组，并将它们组合为同样的数据流形式，它们可以提供端到端的数据传输服务，并且可以在互联网的发送方和接收方之间建立逻辑连接
    
    注：在传输层，“可靠的联网”指使用了 确认，排序，和流量控制。

    TCP(面向连接)传输和UDP(无连接)传输两种方式。

#### 简单介绍传输层面向连接协议(TCP)
    使用TCP协议进行通信之前，要先在通信的设备之间建立一条连接(逻辑连接)，而双方建立连接的这个过程，被称为TCP三次握手(是不是很熟悉)，当三次握手完成后，连接就建立了，也可以开始发送数据了，当数据传送完毕后，这个连接就会断开，关于这个细节后面学习的时候会讲到，现在就先了解一下

    面向连接的特征：
        1. 建立了一条虚电路(三次握手)
        2. 使用了排序
        3. 使用了确认
        4. 使用了流量控制(缓冲，宽口机制，拥塞避免)

    缓冲机制
        接收方在收到发送方要发送数据的请求后，会开辟一块缓冲区，接受的数据就放在缓冲区中来处理，如果缓冲区满了，就会向发送方发送请求，停止发送，等处理完之后又发送请求，可以发送。
    窗口机制
        双方商量好允许发送数据段的数量(字节),这个数量大小就是窗口大小，然后每次发送方就发送指定窗口大小数量的数据，例如
        发送方
            1 2 3 4
        接收方
            收到这4个包后，返回一个确认5，然后接收方收到5后，从第5个包开始发
        注：如果接收方主机不能收到应当确认的所有数据段，它就会减少窗口大小，来改进通信质量。
    
    实现可靠传输(确认机制)
        当发送一个数据段时候，发送方就会启动一个计时器，等带接收方的确认接收的响应包，如果计时器到了，这个包还没到，那么它就会重发。
### 网络层
    网络层(也叫第3层)负责设备的寻址,跟踪网络中设备的位置,并决定传送数据的最佳路径,这意味着网络层必须在位于不同地区的互联设备之间传送数据流。路由器(第3层设备)就工作在网络层,并在互联的网络中提供路由选择服务
    路由器的工作过程为:首先,当路由器的接口收到一个包时,路由器就检查其目的IP地址。如果包不是发给它的,它就在其路由表中查找目的网络地址。一旦路由器选择了一个外出接口(出口),包就被送到那个接口上并封装成帧,最后被送出本地网络。如果路由器在路由表中不能找到对应于包的目的网络的表项,它就丢弃该包。

#### 在网络层当中有两种类型的包：数据包 & 路由更新包
    数据包：在互联网中传递用户数据的，用来支持数据传输的协议叫被动路由协议，例如IP IPv6
    路由更新包：在互联网中，它用来向相邻路由器通告连接到网络的所有路由器的更新信息，发送路由器更新包的协议叫主动路由协议，例如RIP RIPv2，每台路由器上，路由更新包用来帮助和维护路由器表
#### 路由表    
    网络地址    接口    度量 //三个信息组成
    
    网络地址:网络地址(Network addresses)它们是 与特定协议有关的网络地址。路由器必须为各种主动路由协议单独维护一张路由表.因为每个主动路由协议都采用不同的寻址方案(如IP、IPv6和IPX)来跟踪网络。可以把它想像为在某个特定的街道上，不同的居民说着不同的语言,因而有各种不同语言的街道标识。因此,如果街道上有美语、西班牙语和法语居民的话,街道标识就会同时用美语、西班牙语和法语表示出来。

    接口:当数据包被发送到特定的网络时,数据包将选择一个外出接口(出口)。

    度量:度量(Metric)指 到远程网络的距离。不同的主动路由协议采用不同的方式来计算距离。一些主动路由协议(即RIP)采用跳计数(它指的是包被传送到远程网络所经过的路由器的数量)，而其他一些主动路由协议采计数(它指的是包被传送到远程网络所经过的路由器的数量)，而其他一些主动路由协议采用带宽、线路延迟或嘀嗒数(为1/18秒)。用带宽、线路延迟或嘀嗒数(为1/18秒)。

#### 关于路由器的一些知识
    1.默认路由器不转发任何广播包，或组播包
    2.路由器可以使用逻辑地址，逻辑地址在网络层的报头中，用来决定将包转发到下一跳的路由
    3.路由器可以使用管理员创建的访问表来控制被允许进入或流出一个接口的包的安全性
    4.如果需要的话，路由器可以实现2层功能
    5.第三层设备(路由器)可以提供VLAN
    6.路由器可以提供QoS服务

### 数据链路层
    数据链路层提供数据的物理传输，并处理出错通知，网络拓扑和流量控制，这意味着在使用硬件地址的LAN中，数据链路层将保证信息被传送到正确的设备上，并将来着网络层的信息转为比特流的形式，方便物理层传输
    数据链路层将信息封装成数据帧，并添加定制报头，报头中包含了硬件形式的源地址和目的地址，这些被添加的信息围绕在原始信息的周围。

    数据链路层使用硬件寻找的方式，每次在路由器之间传送包时，它就在数据链路层被封装为带控制信息的帧，但这些控制信息将被接收方的路由器剥离，然后只保留原始的数据包，然后这个数据包又被封装成帧，这个过程会在每一跳中继续下去，直到数据包传输到正确的接收方主机，也就是说其实在传输过程中，数据包里面的MAC地址并不是不变的，而是每一跳都会被改变，具体行为是：当前路由抽离第二层信息，然后重新封装的时候发送方MAC会改成自己的目标MAC会改成下一跳路由的，如此重复

#### IEEE Ethernet的数据链路层下的两大子层
    介质访问控制(MAC)
        介质访问控制(Media Access Control,MAC)802.3它定义了数据包怎么在介质上进行传输，在共享同一个带宽链路中，对连接介质的访问是“先来先服务”，物理寻找在此处被定义，逻辑拓扑也在此处被定义，逻辑拓扑是什么？是信号通过物理拓扑的路径，线路控制，出错通知(不纠正),帧的传递顺序和可选择的流量控制都在这一子层实现
    逻辑链路控制(LLC)
        逻辑链路控制(Logical Link Control ,LLC)802.2 它 负责识别网络层协议,然后对它逻辑链路控制(逻辑链路控制)802.2它负责识别网络层协议，然后对它们进行封装。LLC报头告诉数据链路层一旦帧被接收到时,应当对数据包做何处理。它的工作原理是这样的，主机接收到帧并查看其LLC报头，以找到数据包的目的地，比如说，在网络层的IP协议，LLC子层也可以提供流量控制并控制比特流的排序。
#### 交换机
    对于第二层设备，它关注的是设备，而不是网络。
    
    透明桥接:
        二层设备内部会有一个过滤表，这个过滤表被创建之后，二层设备只将帧转发到目的硬件地址所指定的网段，如果目的设备与帧在同一网段上，二层设备将封锁帧，不让他被转发到其他网段，如果目的与帧在不同的网段上，帧就只被转发到那个网段
    
    交换机接口收到带目标硬件地址的帧，而且在交换机的过滤表中找不到这个目的硬件地址时，它将把该帧转发到所有相连的网段上，如果发送"神秘帧"的未知设备响应这个转发行动，交换机就会更新自己的过滤表，添加对比此设备的定位，但是如果发送的帧目的地址为广播地址，默认时交换机将转发所有的广播到每个相连的网段上。

    注：第二层设备传播广播可能会引起广播风暴，唯一的解决办法就是用路由器

### 物理层
    物理层的功能有两个：发送和接收比特流，比特流的值只能是1或0,这一层我不会写太多，因为我现在并不想太关注物理层面
#### 以太网组网
    以太网采用竞争型的介质访问方法，允许网络上所有的主机共享同一条链路的带宽。
    它采用了一种名叫    载波侦听多路访问(Carrier Sense Multiple Access with Collision Detect,CSMA/CD)的冲突检测技术,这是一种介质访问的控制方法，用来帮助网络上的设备均匀地分享带宽，而不会使两台设备同时在网络上传送数据。

    载波侦听多路访问:
        当网络中的不同节点同时传送数据包时，会不可避免的产生冲突，CSMA/CD就是用来解决这种冲突的
        当一台主机想要在网络中传送数据的时候，它首先会检查线路上是否有其他主机的信号正在传送，如果没有就先将自己的数据发送出去，并且不断的监听线路，以确信没有其他主机正在发送数据，并通知网段上其他所有的节点停止发送数据。作为Jam信号的响应，网络上的节点会在试图重新发送数据之前先等一会。退避算法会决定冲突主机什么时候可以重新发送数据，如果在试了15次之后还是产生冲突，试图发送数据的节点将超时。

        简单来说：
            当冲突发生
            Jam信号会让所有设备都知道发生了冲突
            冲突会激活随机退避算法
            以太网中每台设备都会等一小段时间，直到定时器到期
            定时器到期后，所有主机重新发送数据的机会是均等的
#### 以太网的数据链路层
    以太网数据链路层负责以太网寻址，通常称其为硬件寻址或MAC寻址。以太网也负责将从网络层接收下来的数据包组合成帧，并通过以太网连接介质访问的方法在本地网络上进行传输
#### 以太网寻址
    它采用了 介质访问控制(MAC)地址进行寻址，MAC地址被烧入每个以太网卡，所以MAC地址也叫硬件地址(可以伪造MAC地址),它采用了48位(6字节)的MAC地址,以16进制的格式表现，并且MAC地址可不是乱配的，它是有备而来
    前24位是组织唯一标识符(OUI)是由IEEE分配给单位组织的，每个单位组织依次被分配一个全局管理地址(24位/3字节)，对于厂家生产的每一块网卡来说，这个地址是唯一的(不能保证),
![alt MAC](./img/MAC地址.png)
    I/G
        值为0：表示这个地址实际上是设备的MAC地址，它可能出现在MAC报头的源地址部分
        值为1：表示这个地址是以太网中的广播地址或组播地址
    G/L(U/L)
        值为0：表示一个全局管理地址(由IEEE分配)
        值为1：表示一个在管理上统治本地的地址
    后面24为表示本地管理的或厂商分配的代码，由于这个限制的存在，所以每个厂商可以做的网卡数量是限制的
#### Ethernet帧
    数据链路层负责将位组合成字节，并将字节封装成帧，帧被用在数据链路层，从网络层传递过来的数据包被封装成帧，以根据介质访问的类型进行传输，以太网的功能就是使用一组称为MAC帧格式的位，在站点之间进行数据帧传输
    ，采用了循环冗余校验(CRC)进行差错检测
![alt Ethernet](./img/Ethernet.png)
    注:将一个帧封装到不同的类型的帧中，被称为隧道技术
    
    每个字段含义:
        前导:
            采用交替为1和0的模式，每个数据包的起始处提供5MHz的时钟信号，以允许接收设备锁定进入的比特流
            帧起始定界符/同步(Start Frame Delimiter,SFD/Synch)前导为7字节，SFD为1字节、
        DA(Destination Address,目的地址):
            它首先使用最低有效位(LSB)传送48位值，接收方使用DA来决定一个进入的数据包是否被传送往特定的节点，目的地址可以是单独的地址或者是广播或组播的MAC地址
        SA(Source Address, 源地址):
            SA是48位的MAC地址，用来识别发送设备，它首先使用LSB。在SA字段中，广播和组播地址格式是非法的
        长度/类型:
            802.3使用长度字段,但是Ethernet帧使用类型字段来识别网络层的协议。802.3不能识别上层协议，并且必须与专用LAN一起使用
        帧校验序列(Framee Check Sequence,FCS):
            FCS是位于帧末尾的字段，它是用来存放CRC的

> <h2 id="3">数据封装</h2>
    前面有说到七层模型，那么我们要发送的数据在通过每一层的时候都变成什么样子了呢?

    当主机跨越网络向其他设备传送数据时，就要进行数据封装，就是在OSI模型的每一层上加上协议信息，每一层只与接收设备上相应的对等层进行通信。
    为了实现通信并交换信息，每一层都使用了协议数据单元(protocol Data Units,PDU).在模型中的每一层，这些含有控制信息的PDU被附加到数据上，他们通常被附加到数据字段的报头中，但它们也可以被附加在数据字段的报尾中。
    在OSI模型的每一层，通过封装使每个PDU被附加到数据上，而且每个PDU都有特定的名称，其名称取决于在每个报头中所提供的信息。这种PDU信息只能由接收方设备中的对等层读取，在读取后，报头就被剥离，然后把数据交给上一层。
![alt 数据封装](./img/数据封装.png)

    添加的具体内容:
        传输层(数据段)
            源端口  目的端口 ... 数据
        网络层(数据包)
            源IP 目的IP 协议 ... 数据段
        数据链路层(帧)
            目的MAC 源MAC Ether-字段 数据包 FCS
        物理层(比特流)
    
    在实际传输时(跨网段)，帧会被解读，然后重新封装，MAC会更换，源MAC会变成封装帧的设备MAC，然后目标MAC会变成下一跳设备的MAC，但在这个过程中IP是不变的。

> <h2 id="4">Cisco三层模型分层</h2>
    Cisco定义了3个层次(逻辑)，每一层都有特定的功能
        核心层：骨干
        分配层：路由
        接入层：交换

> <h2 id="5">进制转换</h2>
### 2  -> 10
    从右往左开始，每位上的数字(0/1) * 2的n次方,n从0开始递增
    0100 -> 0 * 2^0 + 0 * 2^1 + 1 * 2^2 + 0 * 2^3 = 4
### 10 -> 2
    用10进制数除以2，得出一个商和余数，然后又除以2又得出商和余数，以此类推，然后逆序取值，不足位数的话就高位补0
![alt 十转二](./img/十转二.png)
### 10 -> 16
    16进制一般对应这两个字节，也就是4位一字，例如15的话也是表示0x0F,0x只是个修饰，表示是十六进制
    类似于10转2
![alt 十转十六](./img/十转十六.png)        
### 16 -> 10
    类似于2转10
    FF -> 15 * 16^0 + 15 * 16^1 = 255
### 2 <-> 16
    前面有说过4个比特位表示1个字，也就是一个十六进制位，所以这里有一个对照的转换表，而不通过计算
    二进制  十六进制
     0000     0
     0001     1
     0010     2
     0011     3
     0100     4
     0101     5
     0110     6
     0111     7
     1000     8
     1001     9
     1010     A
     1011     B
     1100     C
     1101     D
     1110     E
     1111     F
***

> <h2 id="6">TCP/IP简介</h2>
    TCP/IP协议(传输控制协议/因特网协议),这个协议的主要作用就是用来维持互联网通信的，TCP/IP协议有一个自己的四层模型，不过这个模型也是对应着OSI七层模型，如图
![alt TCP/IP四层与OSI七层对比](./img/osi_V_TCP-IP.png)
    TCP/IP这四层模型也叫DoD模型，下面开始简述各层的作用
### 应用层
    DoD模型下的应用层中包含了大量的协议，它集成了各种应用和功能来生成一个可以和OSI模型中对应的三个高层相对应的集合，待会下面也会简介一些协议
#### Telnet
    Telnet协议，可以模拟一个终端，它允许用户在远程客户端访问一台机器上面的资源，Telnet是通过在Telnet服务器上运行并且在客户端显示操作结果来实现控制的。
#### FTP(文件传输协议)
    文件传输协议顾名思义其实就是传输文件的协议，它可以应用再任意两台主机之间。但是FTP不仅仅是个协议，它同时也是一个程序，作为协议，FTP是被应用程序所使用的，而作为程序FTP是需要用户通过手动的方式来使用的，
    并且FTP协议允许执行对目录和文件的访问，还可以完成特定类型的目录操作(例如:将文件重新定位到不同的目录中)
    TCP通过与Telnet合作来完成对FTP服务器的登录操作，并在之后开始提供文件传输服务，但是再此之前，用户必须要登录才能开始传输，需要提供正确的账号和密码，但是也可以试试用anonymous来尝试登录。
#### NFS(网络文件系统)
    网络文件系统(NFS)允许一个系统在网络上与它人共享目录和文件
#### SMTP(简单邮件传输协议)
    简单邮件传输协议(SMTP)对应于我们普遍使用的被称为E-mail的应用
#### SNMP(简单网络管理协议)
   简单网络管理协议采集并使用一些有价值的网络信息，它通过从管理站定期或不定期地轮询网络上的设备来获取数据，并要求这些设备透露某些与管理相关的信息。
#### DNS(域名服务)
    域名解析
#### DHCP/BootP
    动态主机配置协议(DHCP)可以为主机分配IP地址，BootP也可以完成给主机分配IP的任务，但是它要求主机的硬件地址必须被手工输入到BootP表中，不过DHCP是自动分配的。
    DHCP可以提供以下服务:
        IP地址
        子网掩码
        域名
        默认网关
        DNS
        WINS信息
    DHCP的是无连接的，用的是UDP
### 传输层
#### 传输控制协议(TCP)
```
    TCP从应用程序获取大段的信息数据，然后将它分割成若干个数据段，TCP会为这些数据段编号并排序，这样的话再目的方的TCP协议栈才可以将这些数据段再重组成原来的数据结构，由于TCP采用的是虚电路的连接方式，这些数据段再被发送出去后，发送方的TCP会等待接收方的TCP给出一个确认性的答案，如果超时了还没有收到确认应答，数据段将被重发。

    虚电路:发送方的TCP协议会通知目的方的TCP协议去建立一个TCP连接，这就是所谓的虚电路，而这种通信也被称为面向连接，在这个连接的初始化过程中(三次握手)，双方的TCP层需要对接收方在返回确认应答之前，可以连续发送多少数量的信息达成一致(窗口大小)

    TCP数据段格式(TCP报头是一个20字节长的段，在带有选项时可以长达24字节)
```
![alt TCP首部](./img/TCP首部.png)
```
各个字段含义
    源端口号(2byte): 主机上应用发送数据的端口号
    目的端口号(2byte): 在目标主机上接收应用程序数据的端口号
    序列号(4byte): 用于将数据编排回原来正确的顺序或者用于对丢失或损坏的数据进行重传的编号
    确认号(4byte): 用于说明下一个所期望接收的TCP序号包
    数据偏移(1byte): 因为有选项这栏的存在，所以TCP报头的长度不是固定的，所以采用这个字段指出数据的开始的位置。
    保留(6bit): 总是被设置为0
    代码位(URG/ACK/PSH/RST/SYN/FIN,6bit): 提供用于建立及结束会话的控制功能
        URG:这个标记表示数据包比较紧急，要优先发送
        ACK: 只要当ACK为1时，确认号才会有用
        SYN: 用于建立会话，当SYN被标记为1时就表示这是一个建立连接的请求
        PSH: 这个被标记为1的话，表示这个包需要优先被读取
        RST: 这个被标记为1的话，表示TCP连接出现了问题，必须要释放连接
        FIN: 这个被标记为1的话，就表示数据传输完毕，可以释放TCP连接了。
    窗口(2byte): 发送方将允许的发送窗口尺寸，用八进制形式表示
    校验和(2byte): 存储循环冗余校验(CRC)，这个字段用于检测报头或者数据是否被改变
    紧急指针(2byte): 只有当URG为1时，里面的数据才有效，它指出了数据包中需要紧急处理数据的尾部在哪
    选项(0/4byte): 没有选项时为0，当有选项时就要占用4字节，不够大小也要用0来填充
    数据: 指被传送到传输层的TCP协议的数据
```
#### 用户数据报协议(UDP)
```
    UDP非常不可靠，因为它不对需要发送的数据段进行排序，而且不关心这些数据段到达目的地的顺序，并且发送完后就完事了，不会关心是否送到，但是UDP的效率会比较高
    UDP不会创建虚电路，所以它又称为无连接的协议

    UDP数据段格式
```
![alt UDP数据首部](./img/UDP首部.png)
```
各个字段含义
    源端口号(2byte): 主机上应用发送数据的端口号
    目的端口号(2byte): 在目标主机上接收应用程序数据的端口号
    长度(2byte): UDP报头和UDP数据的长度
    校验和(2byte): UDP报头和UDP数据的长度
    数据: 上层数据
```
[回到顶部](#menu)