<style>
    body{
        background-color:#7ce8b9;
    }
</style>
# CCNA网络基础知识学习
*内容来源于《CCNA学习指南中文版》,因为这本书里面的知识都很基础，故可以作为基础知识，在这里可能会更注重于一些实践的东西，而不是纯理论*

<h2 id="menu">目录</h2>

* ### [网络模型](#1)
    * 最早的简单网络
        * 集线器
        * 冲突域
        * 广播域
        * 通信过程
    * 划分一个新的网络
        * 使用交换机进行网络分段
    * 互联网最小模型
* ### [OSI七层模型](#2)
    * OSI七层模型简介
    * 应用层
    * 表示层
    * 会话层
    * 传输层
        * 简单介绍传输层面向连接协议(TCP)
    * 网络层
        * 在网络层当中有两种类型的包：数据包 & 路由更新包
        * 路由表
        * 关于路由器的一些知识
    * 数据链路层
        * IEEE Ethernet的数据链路层下的两大子层
        * 交换机
    * 物理层
        * 以太网组网
        * 以太网的数据链路层
        * 以太网寻址
        * Ethernet帧
* ### [数据封装](#3)
* ### [Cisco3层分层模型](#4)
* ### [进制转换](#5)
    * 2  -> 10
    * 10 -> 2
    * 10 -> 16
    * 16 -> 10
    * 2 <-> 16
* ### [TCP/IP简介](#6)
    * 应用层
        * Telnet
        * FTP(文件传输协议)
        * NFS(网络文件系统)
        * SMTP(简单邮件传输协议)
        * SNMP(简单网络管理协议)
        * DNS(域名服务)
        * DHCP/BootP
    * 传输层
        * 传输控制协议(TCP)
        * 用户数据报协议(UDP)
        * TCP和UDP功能对比
    * 网络层
        * 因特网协议(IP)
        * IP首部
        * 因特网控制报文协议(ICMP)
        * 地址解析协议(ARP)
        * 逆向地址解析协议(RARP)
        * 局域网通信理解
        * 实例
        * IP寻址
            * IP术语
            * 分层IP寻址
            * 5类IP地址
            * 私有地址
* ### [子网](#7)
    * 如何创建子网
    * 子网掩码
    * C类地址的子网划分
        * 练习
    * B类地址子网划分
        * 练习
    * A类地址子网划分
    * 可变长度子网掩码(VLSM)
* ### [Cisco的互联网操作系统(IOS)](#8)
    * 什么是IOS
    * 连接Cisco路由器
    * 启动路由器
    * 命令行接口(CLI)
        * 配置模式
        * 路由器术语
        * 进入特权模式
        * 进入全局模式
        * 退出登录
        * 获取帮助信息
        * 全局配置模式
        * 进入接口模式
        * 行命令
        * 常用快捷键
        * 查看历史命令
        * 获取基本路由信息
        * 配置主机名
        * 设置banner信息
        * 设置口令
        * 设置接口描述
        * do命令
        * 接口配置
        * 查看，保存并擦除配置
        * 查看接口信息命令
        * 验证配置
* ### [管理Cisco互连网络](#9)
    * 路由器的内部组件
    * 路由器启动顺序
    * 管理配置寄存器
    * 恢复口令
* ### [IP路由](#10)
    
***

> <h2 id="1">网络模型</h2>
### 最早的简单网络
    主机通过集线器互连
#### 集线器
    关于集线器这种网络设备，可以把它理解为一个扩展接口，例如我们电脑只有一个有线网卡，那么理论上，我们只能连接一台主机，但是集线器上可能有很多接口，那么我们都把许多主机的网线插到集线器上，那么我们就相当于连接了插入其他接口的主机，这就形成了一个网络。

    集线器工作在第二层，所以是只能在局域网使用，并且这个网络中会有一个冲突域和一个广播域
![alt 集线器](./img/集线器.png)
#### 冲突域
    这里先简单说一下什么是冲突域，等到后面有写广播以及ARP的时候或许更能理解，在局域网中使用的是广播通信，在同一时间是只能发送一条信息的，假设两个主机同时发出了一条信息，那么就会产生冲突，结果就是导致谁也发不了信息，这就是冲突域，而且一个网络中的主机越多，冲突域也就越大，发送冲突的可能性也就越高，当然这是有解决方法的，有可以划分冲突域的网络设备
#### 广播域
    二层通信用的就是广播，所谓的广播域就是一个局域网的通信范围，例如这个局域网有30台主机，那么这30台主机就处在一个广播域，也就是说只要在这个网络中发送广播包，它们都能收到，广播域也有网络设备能划分（三层网络设备）
#### 通信过程
    我的IP(192.168.0.2)
    东哥IP(192.168.0.3)
    我现在想和东哥通信，那么我首先要做的是要获取东哥的MAC地址(因为局域网通信用的不是IP，而是MAC地址)
        1.发送广播包(广播的IP是192.168.0.255,MAC是ff:ff:ff:ff:ff:ff,IP可能是随着网段不同会变化，但是MAC是固定的)，内容为192.168.0.3是谁
        2.在这个网络每台设备都会接到这个广播包，然后进行对比，当东哥接到这个广播包后，发现是在找自己，他就会回应这个包(向192.168.0.2发送自己的MAC地址)
        3.我收到它的回应之后就有了它的MAC地址了，这样我们就能通过MAC进行通信了
        4.注意：在我获取到东哥的IP和MAC的时候，东哥也拥有了我的IP和MAC
### 划分一个新的网络
    通过集线器组成的网络我们可以知道，效率是非常低的，而且主机越多效率越低(因为冲突的存在),我们可以通过其他网络设备去划分网络(网络分段)，例如 路由器，交换机，网桥(早就不用了)，
    在继续之前我想先列出一下，在局域网中通信出现网络阻塞的原因
        1.广播域中有太多主机
        2.广播风暴
        3.组播
        4.低带宽
        5.使用了集线器
#### 使用交换机进行网络分段
    交换机这种设备也多用于局域网，进行二层通信(除非是三层交换机),它可以对冲突域进行划分，但是不划分广播域,从下图可以看到,使用交换机划分出了两个冲突域(交换机每个接口都是一个冲突域)，但是广播域就一个
    如果这个网络中的主机很多的话，那么就很容易形成网络堵塞。
![alt 交换机](./img/交换机.png)
### 互联网最小模型
    在这个网络模型中我们将使用路由器(三层设备),在因特网的网络互连中最常见的就是路由器，它的功能非常多(例如路由选址，端口转发),而使用路由器可以对广播域和冲突域进行划分，我对于局域网的理解为一个广播域就是一个局域网，那么划分了多个广播域的话就是多个局域网，这多个局域网之间通信就已经是在跨网段通信了，而因特网也是这样从小成多的连接组成的，所以我说这是互联网的最小模型。
![alt 路由器](./img/路由器.png)

> <h2 id="2">OSI七层模型</h2>
### OSI七层模型简介
    应用层(文件，打印，消息，数据库，应用服务)
    表示层(数据加密，压缩，转换)
    会话层(会话控制)
    传输层(端到端连接)
    网络层(路由选择)
    数据链路层(组帧)
    物理层(物理拓扑)
### 应用层
    应用层是用户与计算机进行实际通信的地方，实际上只有当马上要访问的网络的时候才会用到这一层，最简单的例子是使用浏览器查看本地文档时，这是与网络无关的，但是当我们要使用HTTP协议去请求文档，或者使用FTP进行下载的时候，就需要应用层来协助了，网络通信是软件的一部分，这点很重要，软件可以有很多功能，网络通信只是它的功能之一，

    应用层还负责识别并建立想要通信的计算机一方的可用性，并决定想要的通信是否存在足够的资源。
    应用层是实际应用程序之间的接口。
### 表示层
    表示层为应用层提供数据，并负责数据转换和代码格式化，这层就像一个翻译器
### 会话层
    会话层负责建立，管理和终止表示层实体之间的会话连接，这一层也在设备或节点之间提供会话控制，它在系统之间协调通信过程，提供三种不同的组织方式:
        单工
        半双工
        全双工
### 传输层
    传输层将数据分段并重组为数据流，传输层所提供的服务用于来自上层应用程序的数据进行分段和重组，并将它们组合为同样的数据流形式，它们可以提供端到端的数据传输服务，并且可以在互联网的发送方和接收方之间建立逻辑连接
    
    注：在传输层，“可靠的联网”指使用了 确认，排序，和流量控制。

    TCP(面向连接)传输和UDP(无连接)传输两种方式。

#### 简单介绍传输层面向连接协议(TCP)
    使用TCP协议进行通信之前，要先在通信的设备之间建立一条连接(逻辑连接)，而双方建立连接的这个过程，被称为TCP三次握手(是不是很熟悉)，当三次握手完成后，连接就建立了，也可以开始发送数据了，当数据传送完毕后，这个连接就会断开，关于这个细节后面学习的时候会讲到，现在就先了解一下

    面向连接的特征：
        1. 建立了一条虚电路(三次握手)
        2. 使用了排序
        3. 使用了确认
        4. 使用了流量控制(缓冲，宽口机制，拥塞避免)

    缓冲机制
        接收方在收到发送方要发送数据的请求后，会开辟一块缓冲区，接受的数据就放在缓冲区中来处理，如果缓冲区满了，就会向发送方发送请求，停止发送，等处理完之后又发送请求，可以发送。
    窗口机制
        双方商量好允许发送数据段的数量(字节),这个数量大小就是窗口大小，然后每次发送方就发送指定窗口大小数量的数据，例如
        发送方
            1 2 3 4
        接收方
            收到这4个包后，返回一个确认5，然后接收方收到5后，从第5个包开始发
        注：如果接收方主机不能收到应当确认的所有数据段，它就会减少窗口大小，来改进通信质量。
    
    实现可靠传输(确认机制)
        当发送一个数据段时候，发送方就会启动一个计时器，等带接收方的确认接收的响应包，如果计时器到了，这个包还没到，那么它就会重发。
### 网络层
    网络层(也叫第3层)负责设备的寻址,跟踪网络中设备的位置,并决定传送数据的最佳路径,这意味着网络层必须在位于不同地区的互联设备之间传送数据流。路由器(第3层设备)就工作在网络层,并在互联的网络中提供路由选择服务
    路由器的工作过程为:首先,当路由器的接口收到一个包时,路由器就检查其目的IP地址。如果包不是发给它的,它就在其路由表中查找目的网络地址。一旦路由器选择了一个外出接口(出口),包就被送到那个接口上并封装成帧,最后被送出本地网络。如果路由器在路由表中不能找到对应于包的目的网络的表项,它就丢弃该包。

#### 在网络层当中有两种类型的包：数据包 & 路由更新包
    数据包：在互联网中传递用户数据的，用来支持数据传输的协议叫被动路由协议，例如IP IPv6
    路由更新包：在互联网中，它用来向相邻路由器通告连接到网络的所有路由器的更新信息，发送路由器更新包的协议叫主动路由协议，例如RIP RIPv2，每台路由器上，路由更新包用来帮助和维护路由器表
#### 路由表
    网络地址    接口    度量 //三个信息组成
    
    网络地址:网络地址(Network addresses)它们是 与特定协议有关的网络地址。路由器必须为各种主动路由协议单独维护一张路由表.因为每个主动路由协议都采用不同的寻址方案(如IP、IPv6和IPX)来跟踪网络。可以把它想像为在某个特定的街道上，不同的居民说着不同的语言,因而有各种不同语言的街道标识。因此,如果街道上有美语、西班牙语和法语居民的话,街道标识就会同时用美语、西班牙语和法语表示出来。

    接口:当数据包被发送到特定的网络时,数据包将选择一个外出接口(出口)。

    度量:度量(Metric)指 到远程网络的距离。不同的主动路由协议采用不同的方式来计算距离。一些主动路由协议(即RIP)采用跳计数(它指的是包被传送到远程网络所经过的路由器的数量)，而其他一些主动路由协议采计数(它指的是包被传送到远程网络所经过的路由器的数量)，而其他一些主动路由协议采用带宽、线路延迟或嘀嗒数(为1/18秒)。用带宽、线路延迟或嘀嗒数(为1/18秒)。

#### 关于路由器的一些知识
    1.默认路由器不转发任何广播包，或组播包
    2.路由器可以使用逻辑地址，逻辑地址在网络层的报头中，用来决定将包转发到下一跳的路由
    3.路由器可以使用管理员创建的访问表来控制被允许进入或流出一个接口的包的安全性
    4.如果需要的话，路由器可以实现2层功能
    5.第三层设备(路由器)可以提供VLAN
    6.路由器可以提供QoS服务

### 数据链路层
    数据链路层提供数据的物理传输，并处理出错通知，网络拓扑和流量控制，这意味着在使用硬件地址的LAN中，数据链路层将保证信息被传送到正确的设备上，并将来着网络层的信息转为比特流的形式，方便物理层传输
    数据链路层将信息封装成数据帧，并添加定制报头，报头中包含了硬件形式的源地址和目的地址，这些被添加的信息围绕在原始信息的周围。

    数据链路层使用硬件寻找的方式，每次在路由器之间传送包时，它就在数据链路层被封装为带控制信息的帧，但这些控制信息将被接收方的路由器剥离，然后只保留原始的数据包，然后这个数据包又被封装成帧，这个过程会在每一跳中继续下去，直到数据包传输到正确的接收方主机，也就是说其实在传输过程中，数据包里面的MAC地址并不是不变的，而是每一跳都会被改变，具体行为是：当前路由抽离第二层信息，然后重新封装的时候发送方MAC会改成自己的目标MAC会改成下一跳路由的，如此重复

#### IEEE Ethernet的数据链路层下的两大子层
    介质访问控制(MAC)
        介质访问控制(Media Access Control,MAC)802.3它定义了数据包怎么在介质上进行传输，在共享同一个带宽链路中，对连接介质的访问是“先来先服务”，物理寻找在此处被定义，逻辑拓扑也在此处被定义，逻辑拓扑是什么？是信号通过物理拓扑的路径，线路控制，出错通知(不纠正),帧的传递顺序和可选择的流量控制都在这一子层实现
    逻辑链路控制(LLC)
        逻辑链路控制(Logical Link Control ,LLC)802.2 它 负责识别网络层协议,然后对它逻辑链路控制(逻辑链路控制)802.2它负责识别网络层协议，然后对它们进行封装。LLC报头告诉数据链路层一旦帧被接收到时,应当对数据包做何处理。它的工作原理是这样的，主机接收到帧并查看其LLC报头，以找到数据包的目的地，比如说，在网络层的IP协议，LLC子层也可以提供流量控制并控制比特流的排序。
#### 交换机
    对于第二层设备，它关注的是设备，而不是网络。
    
    透明桥接:
        二层设备内部会有一个过滤表，这个过滤表被创建之后，二层设备只将帧转发到目的硬件地址所指定的网段，如果目的设备与帧在同一网段上，二层设备将封锁帧，不让他被转发到其他网段，如果目的与帧在不同的网段上，帧就只被转发到那个网段
    
    交换机接口收到带目标硬件地址的帧，而且在交换机的过滤表中找不到这个目的硬件地址时，它将把该帧转发到所有相连的网段上，如果发送"神秘帧"的未知设备响应这个转发行动，交换机就会更新自己的过滤表，添加对比此设备的定位，但是如果发送的帧目的地址为广播地址，默认时交换机将转发所有的广播到每个相连的网段上。

    注：第二层设备传播广播可能会引起广播风暴，唯一的解决办法就是用路由器

### 物理层
    物理层的功能有两个：发送和接收比特流，比特流的值只能是1或0,这一层我不会写太多，因为我现在并不想太关注物理层面
#### 以太网组网
    以太网采用竞争型的介质访问方法，允许网络上所有的主机共享同一条链路的带宽。
    它采用了一种名叫    载波侦听多路访问(Carrier Sense Multiple Access with Collision Detect,CSMA/CD)的冲突检测技术,这是一种介质访问的控制方法，用来帮助网络上的设备均匀地分享带宽，而不会使两台设备同时在网络上传送数据。

    载波侦听多路访问:
        当网络中的不同节点同时传送数据包时，会不可避免的产生冲突，CSMA/CD就是用来解决这种冲突的
        当一台主机想要在网络中传送数据的时候，它首先会检查线路上是否有其他主机的信号正在传送，如果没有就先将自己的数据发送出去，并且不断的监听线路，以确信没有其他主机正在发送数据，并通知网段上其他所有的节点停止发送数据。作为Jam信号的响应，网络上的节点会在试图重新发送数据之前先等一会。退避算法会决定冲突主机什么时候可以重新发送数据，如果在试了15次之后还是产生冲突，试图发送数据的节点将超时。

        简单来说：
            当冲突发生
            Jam信号会让所有设备都知道发生了冲突
            冲突会激活随机退避算法
            以太网中每台设备都会等一小段时间，直到定时器到期
            定时器到期后，所有主机重新发送数据的机会是均等的
#### 以太网的数据链路层
    以太网数据链路层负责以太网寻址，通常称其为硬件寻址或MAC寻址。以太网也负责将从网络层接收下来的数据包组合成帧，并通过以太网连接介质访问的方法在本地网络上进行传输
#### 以太网寻址
    它采用了 介质访问控制(MAC)地址进行寻址，MAC地址被烧入每个以太网卡，所以MAC地址也叫硬件地址(可以伪造MAC地址),它采用了48位(6字节)的MAC地址,以16进制的格式表现，并且MAC地址可不是乱配的，它是有备而来
    前24位是组织唯一标识符(OUI)是由IEEE分配给单位组织的，每个单位组织依次被分配一个全局管理地址(24位/3字节)，对于厂家生产的每一块网卡来说，这个地址是唯一的(不能保证),
![alt MAC](./img/MAC地址.png)
    I/G
        值为0：表示这个地址实际上是设备的MAC地址，它可能出现在MAC报头的源地址部分
        值为1：表示这个地址是以太网中的广播地址或组播地址
    G/L(U/L)
        值为0：表示一个全局管理地址(由IEEE分配)
        值为1：表示一个在管理上统治本地的地址
    后面24为表示本地管理的或厂商分配的代码，由于这个限制的存在，所以每个厂商可以做的网卡数量是限制的
#### Ethernet帧
    数据链路层负责将位组合成字节，并将字节封装成帧，帧被用在数据链路层，从网络层传递过来的数据包被封装成帧，以根据介质访问的类型进行传输，以太网的功能就是使用一组称为MAC帧格式的位，在站点之间进行数据帧传输
    ，采用了循环冗余校验(CRC)进行差错检测
![alt Ethernet](./img/Ethernet.png)
    注:将一个帧封装到不同的类型的帧中，被称为隧道技术
    
    每个字段含义:
        前导:
            采用交替为1和0的模式，每个数据包的起始处提供5MHz的时钟信号，以允许接收设备锁定进入的比特流
            帧起始定界符/同步(Start Frame Delimiter,SFD/Synch)前导为7字节，SFD为1字节、
        DA(Destination Address,目的地址):
            它首先使用最低有效位(LSB)传送48位值，接收方使用DA来决定一个进入的数据包是否被传送往特定的节点，目的地址可以是单独的地址或者是广播或组播的MAC地址
        SA(Source Address, 源地址):
            SA是48位的MAC地址，用来识别发送设备，它首先使用LSB。在SA字段中，广播和组播地址格式是非法的
        长度/类型:
            802.3使用长度字段,但是Ethernet帧使用类型字段来识别网络层的协议。802.3不能识别上层协议，并且必须与专用LAN一起使用
        帧校验序列(Framee Check Sequence,FCS):
            FCS是位于帧末尾的字段，它是用来存放CRC的

> <h2 id="3">数据封装</h2>
    前面有说到七层模型，那么我们要发送的数据在通过每一层的时候都变成什么样子了呢?

    当主机跨越网络向其他设备传送数据时，就要进行数据封装，就是在OSI模型的每一层上加上协议信息，每一层只与接收设备上相应的对等层进行通信。
    为了实现通信并交换信息，每一层都使用了协议数据单元(protocol Data Units,PDU).在模型中的每一层，这些含有控制信息的PDU被附加到数据上，他们通常被附加到数据字段的报头中，但它们也可以被附加在数据字段的报尾中。
    在OSI模型的每一层，通过封装使每个PDU被附加到数据上，而且每个PDU都有特定的名称，其名称取决于在每个报头中所提供的信息。这种PDU信息只能由接收方设备中的对等层读取，在读取后，报头就被剥离，然后把数据交给上一层。
![alt 数据封装](./img/数据封装.png)

    添加的具体内容:
        传输层(数据段)
            源端口  目的端口 ... 数据
        网络层(数据包)
            源IP 目的IP 协议 ... 数据段
        数据链路层(帧)
            目的MAC 源MAC Ether-字段 数据包 FCS
        物理层(比特流)
    
    在实际传输时(跨网段)，帧会被解读，然后重新封装，MAC会更换，源MAC会变成封装帧的设备MAC，然后目标MAC会变成下一跳设备的MAC，但在这个过程中IP是不变的。

> <h2 id="4">Cisco三层模型分层</h2>
    Cisco定义了3个层次(逻辑)，每一层都有特定的功能
        核心层：骨干
        分配层：路由
        接入层：交换

> <h2 id="5">进制转换</h2>
### 2  -> 10
    从右往左开始，每位上的数字(0/1) * 2的n次方,n从0开始递增
    0100 -> 0 * 2^0 + 0 * 2^1 + 1 * 2^2 + 0 * 2^3 = 4
### 10 -> 2
    用10进制数除以2，得出一个商和余数，然后又除以2又得出商和余数，以此类推，然后逆序取值，不足位数的话就高位补0
![alt 十转二](./img/十转二.png)
### 10 -> 16
    16进制一般对应这两个字节，也就是4位一字，例如15的话也是表示0x0F,0x只是个修饰，表示是十六进制
    类似于10转2
![alt 十转十六](./img/十转十六.png)        
### 16 -> 10
    类似于2转10
    FF -> 15 * 16^0 + 15 * 16^1 = 255
### 2 <-> 16
    前面有说过4个比特位表示1个字，也就是一个十六进制位，所以这里有一个对照的转换表，而不通过计算
    二进制  十六进制
     0000     0
     0001     1
     0010     2
     0011     3
     0100     4
     0101     5
     0110     6
     0111     7
     1000     8
     1001     9
     1010     A
     1011     B
     1100     C
     1101     D
     1110     E
     1111     F
***

> <h2 id="6">TCP/IP简介</h2>
    TCP/IP协议(传输控制协议/因特网协议),这个协议的主要作用就是用来维持互联网通信的，TCP/IP协议有一个自己的四层模型，不过这个模型也是对应着OSI七层模型，如图
![alt TCP/IP四层与OSI七层对比](./img/osi_V_TCP-IP.png)
    TCP/IP这四层模型也叫DoD模型，下面开始简述各层的作用
### 应用层
    DoD模型下的应用层中包含了大量的协议，它集成了各种应用和功能来生成一个可以和OSI模型中对应的三个高层相对应的集合，待会下面也会简介一些协议
#### Telnet
    Telnet协议，可以模拟一个终端，它允许用户在远程客户端访问一台机器上面的资源，Telnet是通过在Telnet服务器上运行并且在客户端显示操作结果来实现控制的。
#### FTP(文件传输协议)
    文件传输协议顾名思义其实就是传输文件的协议，它可以应用再任意两台主机之间。但是FTP不仅仅是个协议，它同时也是一个程序，作为协议，FTP是被应用程序所使用的，而作为程序FTP是需要用户通过手动的方式来使用的，
    并且FTP协议允许执行对目录和文件的访问，还可以完成特定类型的目录操作(例如:将文件重新定位到不同的目录中)
    TCP通过与Telnet合作来完成对FTP服务器的登录操作，并在之后开始提供文件传输服务，但是再此之前，用户必须要登录才能开始传输，需要提供正确的账号和密码，但是也可以试试用anonymous来尝试登录。
#### NFS(网络文件系统)
    网络文件系统(NFS)允许一个系统在网络上与它人共享目录和文件
#### SMTP(简单邮件传输协议)
    简单邮件传输协议(SMTP)对应于我们普遍使用的被称为E-mail的应用
#### SNMP(简单网络管理协议)
   简单网络管理协议采集并使用一些有价值的网络信息，它通过从管理站定期或不定期地轮询网络上的设备来获取数据，并要求这些设备透露某些与管理相关的信息。
#### DNS(域名服务)
    域名解析
#### DHCP/BootP
    动态主机配置协议(DHCP)可以为主机分配IP地址，BootP也可以完成给主机分配IP的任务，但是它要求主机的硬件地址必须被手工输入到BootP表中，不过DHCP是自动分配的。
    DHCP可以提供以下服务:
        IP地址
        子网掩码
        域名
        默认网关
        DNS
        WINS信息
    DHCP的是无连接的，用的是UDP

### 传输层
    传输层做数据分段，以及指定好通信端口(1024号端口都是被指定了一些默认服务或应用，所以我们自己调用端口的时候最好使用1024后面的)，端口号是用来区分会话的(不然一个主机上许多进程通信，谁知道哪个包是给谁的呢),
#### 传输控制协议(TCP)
```
    TCP从应用程序获取大段的信息数据，然后将它分割成若干个数据段，TCP会为这些数据段编号并排序，这样的话再目的方的TCP协议栈才可以将这些数据段再重组成原来的数据结构，由于TCP采用的是虚电路的连接方式，这些数据段再被发送出去后，发送方的TCP会等待接收方的TCP给出一个确认性的答案，如果超时了还没有收到确认应答，数据段将被重发。

    虚电路:发送方的TCP协议会通知目的方的TCP协议去建立一个TCP连接，这就是所谓的虚电路，而这种通信也被称为面向连接，在这个连接的初始化过程中(三次握手)，双方的TCP层需要对接收方在返回确认应答之前，可以连续发送多少数量的信息达成一致(窗口大小)

    TCP数据段格式(TCP报头是一个20字节长的段，在带有选项时可以长达24字节)
```
![alt TCP首部](./img/TCP首部.png)
```
各个字段含义
    源端口号(2byte): 主机上应用发送数据的端口号
    目的端口号(2byte): 在目标主机上接收应用程序数据的端口号
    序列号(4byte): 用于将数据编排回原来正确的顺序或者用于对丢失或损坏的数据进行重传的编号
    确认号(4byte): 用于说明下一个所期望接收的TCP序号包
    数据偏移(1byte): 因为有选项这栏的存在，所以TCP报头的长度不是固定的，所以采用这个字段指出数据的开始的位置。
    保留(6bit): 总是被设置为0
    代码位(URG/ACK/PSH/RST/SYN/FIN,6bit): 提供用于建立及结束会话的控制功能
        URG:这个标记表示数据包比较紧急，要优先发送
        ACK: 只要当ACK为1时，确认号才会有用
        SYN: 用于建立会话，当SYN被标记为1时就表示这是一个建立连接的请求
        PSH: 这个被标记为1的话，表示这个包需要优先被读取
        RST: 这个被标记为1的话，表示TCP连接出现了问题，必须要释放连接
        FIN: 这个被标记为1的话，就表示数据传输完毕，可以释放TCP连接了。
    窗口(2byte): 发送方将允许的发送窗口尺寸，用八进制形式表示
    校验和(2byte): 存储循环冗余校验(CRC)，这个字段用于检测报头或者数据是否被改变
    紧急指针(2byte): 只有当URG为1时，里面的数据才有效，它指出了数据包中需要紧急处理数据的尾部在哪
    选项(0/4byte): 没有选项时为0，当有选项时就要占用4字节，不够大小也要用0来填充
    数据: 指被传送到传输层的TCP协议的数据
```
#### 用户数据报协议(UDP)
```
    UDP非常不可靠，因为它不对需要发送的数据段进行排序，而且不关心这些数据段到达目的地的顺序，并且发送完后就完事了，不会关心是否送到，但是UDP的效率会比较高
    UDP不会创建虚电路，所以它又称为无连接的协议

    UDP数据段格式(如果没有数据就是8字节)
```
![alt UDP数据首部](./img/UDP首部.png)
```
各个字段含义
    源端口号(2byte): 主机上应用发送数据的端口号
    目的端口号(2byte): 在目标主机上接收应用程序数据的端口号
    长度(2byte): UDP报头和UDP数据的长度
    校验和(2byte): UDP报头和UDP数据的长度
    数据: 上层数据
```
#### TCP和UDP功能对比
```
    TCP              UDP
    排序             无序
    可靠            不可靠
   面向连接         无连接
    虚电路          低开销
    确认            无确认
 窗口流量控制   没有窗口或流量控制
```

### 网络层
#### 因特网协议(IP)
    因特网协议(IP)实际上就是网络层，其他的协议都是建立在这个协议基础上建立起来的。
    IP关注每个数据包的地址，通过使用路由表，IP可以决定一个数据包将发送给哪一个被选择好的后续最佳路径。
#### IP首部
![alt IP首部](./img/IP首部.png)
```
首部各字段含义(一般是20字节):
    版本(4bit): IP版本号
    首部长度(4bit): 报头的长度
    区分服务(1byte): 服务类型描述数据将如何被处理，前三位表示优先级
    总长度(2byte): 包括报头和数据的数据包长度
    标识(2byte): 唯一的IP数据包值
    标志(4bit): 说明是否有数据被分段
    片偏移(12bit): 如果数据包在装入时帧太大了，需要进行分段和重组，分段功能允许在因特网上存在有不同大小的最大传输单元(MUT)
    生存时间(1byte): TTL，存活期是在数据包产生时建立在其内部的一个设置，如果这个数据包在这个TTL到期时仍没有到达目的地，它就会被丢弃，这个设置将防止IP包在寻找目的地的时候在网络中不断循环 
    协议(1byte): 上层协议的协议号，是十六进制
        协议            协议号
        ICMP             1
      IP in IP(隧道)     4
        TCP              6
        IGMP             9
        UDP              17
        EIGRP            88
        OSPF             89
        IPv6             41
        GRE              17
      第2层隧道(L2TP)     115
        

    首部检验和(2byte): 只针对报头的循环冗余校验(CRC)
    源地址(4byte): 发送方的IP地址
    目的地址(4byte): 接收方的IP地址
    选项(4byte): 用于网络检测，调试，安全以及更多内容
```
#### 因特网控制报文协议(ICMP)
    因特网控制报文协议(ICMP)工作在网络层，它被IP用于提供许多不同的服务。ICMP是一个管理性协议，并且也是一个IP信息服务的提供者，它的信息是被作为IP数据报来传送的。
    ICMP包的特性:
        能为主机提供有关网络故障的信息。
        被封装在IP数据包内。
    我们常使用的ping命令使用的就是ICMP协议，下面是一些ICMP相关的常见的事件或信息。
        目的不可达:路由器不能在向前转发数据报。
        缓冲区满:路由器用于接收输入数据报的内存缓冲区已经满了，它将会使用ICMP向外发送这些信息，直到拥塞解除。
        ping:检测计算机物理和逻辑连接的连通性。
        Traceroute:Traceroute通过使用ICMP的超时机制来发现一个数据包在穿越互联网络时它所经历的路径,(cmd命令为:tracert)
#### 地址解析协议(ARP)
    地址解析协议(ARP)可用由已知主机的IP地址在网络上查找到它的硬件地址，它的工作过程是这样的:当IP有一个数据报需要发送时，他必须要告诉某个网络访问协议，接收方主机在本地网络上的硬件地址，如果IP不能在ARP缓存中找到目的方主机的硬件地址，那么它就会使用ARP去获取这个地址

    ARP会通过发送一个广播数据包来询问本地的网络，要求使用这一指定IP地址的计算机应答其自身的硬件地址。因此可以说ARP能够实现软件(IP)地址到硬件地址的转换，并且能够通过广播判断出它在局域网上的位置

    简单来说 ARP的功能就是 IP -> MAC 的转换
![alt ARP包](./img/ARP包.png)
#### 逆向地址解析协议(RARP)
    当一台主机只有MAC地址而不知道自己的IP地址的时候，它可以通过发送广播包的办法，询问自己的IP地址是多少，这时候拥有RARP服务的主机就会响应这个请求，并告诉它，它的IP
#### 局域网通信理解
    前面有说ARP而在更早之前我也说过，局域网通信使用的是广播，和MAC地址，IP在这里面的作用似乎不那么重要，但是却又不可缺少

#### 实例
实验环境
![alt 环境](./img/LAN1.png)
```
    这个局域网内有三台主机，一台交换机。

    通信流程:
        假设PC0要和PC1进行通信，那么这里使用ping命令来进行通信,但是前面就有说过，局域网内不用IP寻址，使用 ping 192.168.0.3,
        那现在PC0就会发一条广播包，询问谁是192.168.0.3(这个时候PC0和PC1的ARP解析表也是空的)
        (可以通过arp -a命令查看)
```
![alt arp-a](./img/arp-a.png)
```
    然后广播包发出来之后，所有主机都收到这个询问包，然后和自己的IP对一下，PC1拿到这个包和自己一对，发现这个孙子找的是自己，然后就回了一个响应包，你爷爷在此(附上自己的MAC地址)，
    然后当PC0接到这个包之后，心想好家伙这么嚣张，这能忍？，必须的记住它，然后就往自己的ARP缓存表中添加了一条映射关系 [192.168.0.3 它的MAC地址],有了这条记录之后，
    它每次找PC1只需要查找自己的ARP缓存表就能知道它的MAC地址，下次就能直接和PC1通信了，在这个过程中，PC1也会在自己的ARP缓存中记住PC0的IP和MAC地址映射。
```
![alt LAN2](./img/LAN2.png)
```
    在这个过程中，交换机也会对这两者的IP地址和MAC地址映射进行存储，之前就说过交换机有缓存表，而且在这个网络中数据包全是通过交换机来进行发送的，所以下次在有人找这两货的时候交换机就知道要发给哪个接口了。
```
```
IP地址在局域网中的作用似乎不那么重要，但是却又不可缺少这句话如何理解，理论上上来说，通过MAC地址通信那么IP地址有没有都行的，但是为什么又说它不可缺少呢，我觉得是对于用户来说，
就拿我们来说，如果没有IP地址，那么我要Ping，去Ping谁呢？所以是我们需要用IP地址去映射MAC地址进行通信，而不是局域网通信需要IP地址

注：这里对局域网的定义仅仅是一个段，如果有人说 192.168.0.0是一个局域网 192.168.1.0也是一个局域网，那么它们之间通过路由连接是一个更大的局域网，但是它们用到了IP。
```
#### IP寻址
    IP地址是IP网络上每台计算机的数字标识符，它指明了在此网络上某个设备的位置，IP地址是一个软件地址，而不是硬件地址(被硬编码烧录到网卡中)，并且主要用于在本地网络上定位主机，IP寻址允许在某网络上的主机与另一个不同网络上的主机进行通信，并在此过程中无需考虑这两台主机所在的具体局域网的类型差异
##### IP术语
    在学习IP寻址之前，了解一些IP术语

    位: 指bit位，要么是0要么是1
    字节: 一个字节一般是为8位，但是也有说可以是7位，具体是取决于是否使用了检验位
    八位位组: 就是8位
    网络地址: 它是在将数据包发送到远程网络的路由中使用的名称，例如 15.0.0.1
    广播地址：被应用程序和主机用于将信息发送到网络上所有节点的地址
##### 分层IP寻址
    一个IP地址由32位组成，这些位通常被分割为4个部分，一个部分8位，它有3种不同的表现形式
    点分十进制:172.16.30.56
    二进制:10101100.00010000.00011110.00111000
    十六进制:AC.10.1E.38

    对于IP地址的分层，它是这样分的
        网络地址    子网地址    主机地址 //这些地址具体占多少位，怎么划分不固定，看人
        或者是
        节点地址
    网络地址:
        网络地址唯一指定了每个网络，同一网络中的每台计算机都共享相同的网络地址，并用它作为自己IP地址的一部分，例如在 192.168.0.1中,192.168.0就是这个网络的地址.
    主机地址:
        标识主机的地址，例如上面的192.168.0.1中的0.1就是主机地址
    节点地址:
        在一个网络中用来标识每台计算机的，它是一个唯一的标识符，这个地址的节点部分必须唯一
##### 5类IP地址
```
    A类 网络地址 主机地址 主机地址 主机地址
    B类 网络地址 网络地址 主机地址 主机地址
    C类 网络地址 网络地址 网络地址 主机地址
    D类 组播
    E类 研究
```
```
    A类:
        第一部位的第一位必须是0，用来标识这是一个A类地址，那么它的最大值也只能是7个1，也就是说A类地址的网络地址只能是,0~127
    B类:
        第一部分的第一位必须是1，第二位必须是0，也就说它最小是 1000 0000 最大是 1011 1111,也就是说B类地址的网络地址只能是,128~191
    C类:
        按照规律，前两位必须是1，第三位必须是0，最小:1100 0000 最大 1101 1111,也就是说C类地址的网络地址只能是192~223
    D类:
        224~239,用于组播
    E类:
        240~255用于科学实验

    D类和E类这里不考虑
```
```
    在A,B,C类中有一些特殊地址被保留下来有一些特殊含义，下面记录一下

    网络地址全为0                   指这整个网络或者分段
    网络地址全为1                   指全部网络
    127.0.0.1-127.255.255.255      被保留用于环回测试，指向本地，用这个地址发送的测试数据包不会产生网络流量
    主机地址全部为0                 指网络中任意一台主机
    主机地址全部为1                 指当前网络中所有节点
    255.255.255.255                在当前网络上进行广播的地址
    0.0.0.0                        指向默认路由，也可以指任意网络
    10.0.0.1-10.255.255.255        私有地址
    172.16.0.1-172.31.255.255      私有地址
    169.254.0.0-169.254.255.255    保留地址，如果你的IP地址是自动获取IP，但是网络上又没找到DHCP服务器，这时候就会从这里面随机获取一个地址
    192.168.0.1-192.168.255.254    私有地址
```
##### 私有地址
    私有地址是用来构建私有网络的，它们不属于公网IP，无法通过路由进入因特网，1来为了安全考虑，2来也是为了节省宝贵的IP地址，我们现在的上网环境多数都依赖于NAT这种转换技术，后面也会说到

> <h2 id="7">子网</h2>
### 如何创建子网
    要创建子网，就需要从IP地址的主机部分中借出一定的位，并保留它们用来定义子网地址，这意味着用于主机的位减少，所以子网越多，可用于定义主机的位就越少

    记住2的幂
        2^1 = 2
        2^2 = 4
        2^3 = 8
        2^4 = 16
        2^5 = 32
        2^6 = 64
        2^7 = 128
        2^8 = 254
        2^9 = 508
        2^10 = 1024
### 子网掩码(用来判断自己与目标是否处在同一网段)
    为了保证所配置的子网地址可以工作，网络中的每台计算机都必须知道自己的主机地址中的哪一部分是被用来表示子网地址的。这可以通过在每台计算机上指定一个子网掩码来完成
    子网掩码是一个32位的值，通过它接收IP数据包的一方可以从IP地址的主机号部分中区分出子网ID号地址

    使用1和0组合来创建一个32位的子网掩码，子网掩码中的1位置表示网络或子网的地址部分，不是所有的网络都需要子网掩码，有一些主机使用默认的子网掩码
    A类默认 255.0.0.0 //在这种掩码下，网络号相同是一个网段，例如 10.0.0.1 和 10.1.1.1 是在同一个网段
    B类默认 255.255.0.0 //同上，只不过B类的网络号是2个点位 172.16.1.1 和 172.16.2.2 是一个网段 和 172.20.20.20不是同一个网段
    C类默认 255.255.255.0 //C类的网络号是3个点位 192.168.1.1 和 192.168.1.2是一个网段 和 192.168.2.1不是一个网段

    还有另外一种表示子网划分的方法，就是使用/,例如C类 192.168.0.0/24  = 192.168.0.0 255.255.255.0,后面这个24就表示有多少位被设置为1，也就是网络位
    由于IP地址有4个字节也就是32位，所以它最大能被设置为1的位数只有30位，因为必须为主机位保留至少2位
    A类只能用 /8~/15表示
    B类只能用 /16~/23表示
    C类只能用 /24~/30表示

### C类地址的子网划分
    要划分子网就是占用主机位，C类地址就还有8位主机位，那么它最多只能被占用6位(因为最少保留2位主机位),这个过程一定是从左往右开始的，而且中间不能跳过某些位
    也就是说C类的子网掩码只能是
    1000 0000 = 128 /25
    1100 0000 = 192 /26
    1110 0000 = 224 /27
    1111 0000 = 240 /28
    1111 1000 = 248 /29
    1111 1100 = 252 /30
    
    如何计算出划分了多少子网，以及每个子网有多少主机，还记得之前说的2次幂吗
    多少子网？ 2^x = 子网数目 x=掩码中1的数量
    每个子网多少主机？ 2^y - 2 = 主机数量 y=掩码中0的数量,-2是因为有一个子网地址，广播路由地址
    例如 /25，才1个1，所以就划分了两个子网，而有7个0，所以有 2^7 -2 = 126
    
    哪些子网是合法的呢？
    256 - 子网掩码 = 块的大小
    256 - 128 = 128，即0是一个子网，128又是一个子网

    这些子网中的广播地址又是什么呢?
    每个子网中的广播地址是紧邻下一个子网的地址

    192.168.0.0 255.255.255.128
    192.168.0.1-127 是一个网段，广播地址是192.168.0.127，子网地址是 192.168.0.0
    192.168.0.128-255 是一个网段，广播地址是192.168.0.255，子网地址是 192.168.0.128
#### 练习
* 192.168.1.1 255.255.255.192 (/26)
```
    几个子网? 2^2 = 4
    每个子网多少个主机? 2^6 - 2 = 62 
    有效子网? 0 64 128 192
    每个子网的广播地址和子网地址
        子网地址    广播地址
     192.168.1.0  192.168.1.63
     192.168.1.64 192.168.1.127
     192.168.1.128 192.168.1.191
     192.168.1.192 192.168.1.255
```
* 192.168.1.1 255.255.255.224 (/27)
```
    几个子网? 2^3 = 8
    每个子网多少个主机? 2^5 - 2 = 30 
    有效子网? 0 32 64 96 128 160 192 224
    每个子网的广播地址和子网地址:省略
```
* 192.168.1.1 255.255.255.240 (/28)
```
    几个子网? 2^4 = 16
    每个子网多少个主机? 2^4 - 2 = 14
    有效子网? 0 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240
    每个子网的广播地址和子网地址:省略
```
* 192.168.1.1 255.255.255.248 (/29)
```
    几个子网? 2^5 = 32
    每个子网多少个主机? 2^3 - 2 = 6
    有效子网? 0 8 16 24 30 ......
    每个子网的广播地址和子网地址:省略
```
* 192.168.1.1 255.255.255.252 (/30)
```
    几个子网? 2^6 = 64
    每个子网多少个主机? 2^2 - 2 = 2
    有效子网?0 4 8 12 16.......
    每个子网的广播地址和子网地址:省略
```
### B类地址子网划分
    经过前面的C类练习，现在进行进阶，B类可能出现的子网掩码有
    255.255.0.0 /16
    255.255.128.0 /17
    255.255.192.0 /18
    255.255.224.0 /19
    255.255.240.0 /20
    255.255.248.0 /21
    255.255.252.0 /22
    255.255.254.0 /23
    255.255.255.0 /24
    255.255.255.128 /25
    255.255.255.192 /26
    255.255.255.224 /27
    255.255.255.240 /28
    255.255.255.248 /29
    255.255.255.252 /30
    等掩码到了/24之后这个B类地址就和C类地址很类似了
#### 练习
* 172.16.0.0 255.255.128.0 (/17)
```
    几个子网? 2 ^ 1 = 2
    每个子网多少个主机? 2^15 - 2 = 32766
    有效子网? 172.16.0.0 172.16.128.0
    每个子网的广播地址和子网地址:
        子网地址    广播地址
    172.16.0.0     172.16.127.255
    172.16.0.128   172.16.255.255
```
* 172.16.0.0 255.255.192.0 (/18)
```
    几个子网? 2^2 = 4
    每个子网多少个主机? 2^14 - 2 = 16382
    有效子网?0.0 64.0 128.0 192.0
    每个子网的广播地址和子网地址:省略
```
* 172.16.0.0 255.255.224.0 (/19)
```
    几个子网? 2^3 = 8
    每个子网多少个主机? 2^13 - 2 = 8190
    有效子网? 0.0 32.0 64.0 96.0 128.0 160.0 192.0 224.0
    每个子网的广播地址和子网地址:省略
```
### A类地址子网划分
这个就不写了，和B,C基本一样的方法
### 可变长度子网掩码(VLSM)
    有类路由:无论是RIPv1还是IGRP路由选择协议，都没有为子网信息设置字段，因而子网的信息都会被丢弃，这就意味着，如果一个运行RIP的路由器设置了某个数值的子网掩码，它会假定在这个有类地址区域内的所有端口都
    使用了相同的子网掩码，如果在这个网络中混合使用了不同长度的子网掩码，这个网络就无法正常工作

    无类路由:使用RIPv2，EIGRP或OSPF等路由选择协议来使用VLSM，这样可以混合使用不同长度的子网掩码，可以节省大量IP
    通过VLSM可以将一个子网划分为更小的子网

> <h2 id="8">Cisco的互联网操作系统(IOS)和安全设备管理器(SDM)</h2>
### 什么是IOS
    ISO(互联网操作系统):IOS是运行在Cisco路由器和某些Cisco交换机上的操作系统，它允许我们通过远程连接配置这台设备。

    IOS是Cisco路由器和大多数交换机的核心，这个核心是操作系统基本的，不可缺少的部分，它用于完成资源定位以及对低层硬件接口和安全的管理操作，我们可以使用CLI(命令行界面),SDM(安全设备管理器)去操作它
### 连接Cisco路由器
    1.通过控制台端口进行连接,在路由器的背面有一个控制台端口，一般是RJ-45连接器，使用RJ-45接口进行接入
    2.通过辅助端口连接，它和控制台端口差不多，但是使用辅助端口前，需要配置好相关的端口MODEM命令，这种方式叫out-of-band(脱离网络)
    3.通过in-band,通过网络来配置，使用telnet命令
### 启动路由器
    当初次启动一台路由时，它将运行开机自检(POST)过程，如果通过了，它就会去闪存中查找Cisco IOS，如果有IOS文件存在，则会执行装载操作，然后IOS将继续加载并查找一个合法的配置文件(启动配置)，它默认是存储在
    非易失RAM(或NVRAM)中的。

    当加载完毕后，路由器就会显示来至POST的信息，当然这是得在连接路由器的命令行界面才能看到，其实现在版本的POST信息会告诉你很多东西，例如这个路由器有几个快速以太网接口，可以实现什么功能，
    这里就不列举了，可以自己使用Cisco模拟器放一台路由器出来看

    当IOS被加载，启动并运行时，一个预先配置好的配置文件(startup-config)将从NVRAM复制到RAM中，此文件的拷贝被放置在RAM中，并将它称为running-config
    当你开始可以对路由器进行配置的时候，它会询问你是否要进入配置模式,一般是不用进入输入no就好(它就是让你配置一些路由的主机名，以及一些模式的密码什么的)
### 命令行接口(CLI)
这里使用telnet接入路由器
#### 配置模式
    Router> //用户模式，通常用来查看统计信息，和进入到特权模式
    Router# //特权模式,可以查看并且修改Cisco路由器的配置
    Router(config)# //全局配置模式,这个模式下运行的能影响整个路由器的命令叫全局命令,它会修改被称为当前运行配置文件中的内容
    Router(config-if)# //接口配置模式
    Router(config-line)# //行命令模式
    Router(config-router)# //路由协议配置
#### 路由器术语
    用户模式    被限定于基本的监视操作命令
    特权模式    提供对所有路由器命令的访问
    全局配置模式    提供可以影响整个系统运行的命令
    特定配置模式    只提供可以影响接口/进程运行的命令
    设置模式    提供可交互的配置对话方式
#### 进入特权模式
    Router>enable //en也能进入特权模式，它是enable的缩写
#### 进入全局模式
    Router>#configure terminal //config也能进入全局模式，注意全局模式要通过特权模式进入
    Router#disable //返回用户模式
#### 退出登录
    Router> logout
#### 获取帮助信息
    ?   //获取当前能用的命令
    命令 ? //获取这个命令使用的下一个选项
    c? //查看c开头的命令，c可以替换成其他字符
    如果返回的帮助信息太多可以按空格键来到下一页，按Q或者其他任意字符退出
#### 全局配置模式
    Router>enable
    Router#
    Router#configure terminal //简写config
    Router(config)#
    在这个模式中所做的改变会影响整个路由器的工作性能，因此这个模式被称为全局配置模式.
#### 进入接口模式(需要在全局配置模式下使用interface)
    Router#config //进入全局配置模式
    Router(config)#interface ? //查看有多少端口，interface可以缩写为int
    Router(config)#:interface fastEthernet 0/0 //例如我要配置一个快速以太网接口
    Router(config-if)#  //这就表示已经进入了接口配置模式，记住配置哪个接口就进接口
    Router(config-if)#end //直接退到特权模式
#### 行命令
    //这个命令模式我现在只知道它能设置口令
    Router(config)# line ? //看看行命令模式有哪些选项
#### 常用快捷键
    Ctrl + U //删除一行
    Ctrl + A //光标移动到本行开始
    Ctrl + E //光标移动到本行结束
    Tab     //自动补齐
#### 查看历史命令
    Router>show history
    Router>terminal history size 256 //修改历史命令的缓存大小
#### 获取基本路由器信息
    show version //查看系统硬件的基本配置，以及软件版本号和引导映像
#### 配置主机名(只在局部起作用)
    Router(config)#:hostname Test
    Test(config)#:
#### 设置banner信息
    Router(config)#:banner login # //设置登录时会输出的提示信息，#表示结束符，你可以输很多话，然后输入#结束
    还能设置其他banner信息，可以通过 banner ? 查看
#### 设置口令
    首先有5种口令
        控制台口令
        辅助口令
        远程登录口令(VTY)
        启用口令
        启用加密口令
    启用加密口令和启用口令用于设置保护特权模式的口令，在使用enable命令时，它会提示用户输入一个口令，其他3个是用于配置通过控制台，辅助端口，或者通过Telnet访问用户模式的口令
    注意:Cisco不允许哪个接口在没设置密码前被使用
    
    设置特权模式口令:
    Router(config)#: enable ? //可以查看配置保护特权模式的口令
        password // 在老路由器上设置启用口令，如果启用加密口令被设置了，它就不能被使用了
        secret // 设置加密口令
    
    指定用户模式口令
    Router(config)#: line ?
        aux //为辅助端口设置用户模式口令
        console //设置控制台的用户模式口令
        vty //设置路由器上的telnet口令，如果没有设置那么telnet是不可用的

    设置辅助端口口令
    Router(config)#line aux 接口号
    Router(config-line)#login //设置登录时要使用的密码，这里什么都没设直接login，就表示不要密码,跳过验证
    Router(config-line)#password 密码
    Router(config-line)#login //这里就会启用上面设置的那个登录密码

    设置vty口令
    Router(config)#line vty ? //这里要选接口，通常会有很多接口，可以指定范围，例如
    Router(config)#line vty 0 15
    Router(config-line)#password admin
    Router(config-line)#login

    Router(config-line)#no login //表示允许建立无密码连接的vty

    设置console口令
    Router(config)#line console 0
    Router(config-line)#exec-timeout 0 0 //这里是设置控制台的超时状态，应该是多久不进行操作就会自动断开,0 0表示绝对不允许超时
    Router(config-line)#password admin
    Router(config-line)#login


    加密口令
        默认情况下只有加密口令是被加密的，使用 Router#show running-config //就可以查看到除了加密口令外的其他口令明文
        我们可以手工加密口令
        Router(config)#:service passwrod-encryption //这时候口令就被加密了
        Router(config)#:no service password-encryption //取消加密
    
#### 设置接口描述
        Router(config)#:int 接口 //interface的缩写就是int
        Router(config-if)#:description 描述信息
        Rotuer#sh run //show running-config的缩写，使用这个命令可以查看到接口描述
        Router#show interface //上面那个显示的信息太多，这个只查看接口信息，简写sh int
#### do命令
    有些命令是要在特定的模式下执行的，例如sh run,要在全局模式下执行，但是如果我们要在接口模式下进行操作，那么就要推出去，然后执行完又重新进来，就很麻烦
    但是有了do命令就不一样了，它支持你可以在,不匹配的模式下去执行查看配置文件和统计数据的命令
    Router(config-if)#sh run //报错，因为权限模式错了
    Router(config)#do sh run

#### 接口配置
    接口类型
        serial 串行接口
        ethernet 以太网接口
        fastEthernet 快速以太网接口
    配置接口
    Router(config)#interface 接口 接口号
    //例如配置快速以太网接口 0/0
    Router(config)#interface fastEthernet 0/0 //这里可以缩写为 int f0/0
    //查看端口号
    Router(config)#interface fastEthernet ? // int f ?
    Router(config)#interface fastEthernet 0/? //int f ?/?
    //配置IP地址
    Router(config-if)#ip address IP地址 子网掩码
    //配置第二个IP,这个基本不用，了解就好
    Router(config-if)#ip address IP地址 子网掩码 secondary
     接口配置好后要进行激活
    Router(config-if)#no shutdown //打开端口
    Rotuer(config-if)#shutdown //关闭端口
    //查看所有接口的逻辑地址和开启状态
    Router#:sh ip int brief
    //查看每个接口的状态和IP地址
    Router#sh protocols
   
    //配置路由器IP接口
    Router#config t
    Router(config)#int f 0/0
    Router(config-if)#ip address 192.168.0.1 255.255.255.0
    Router(config-if)#no showdown
#### 查看，保存并擦除配置
    Router#copy running-config startup-config //将配置好的running-config文件去覆盖startup-config文件
    Router#erase startup-config //删除startup-config文件
    Router#reload //重新加载配置
#### 查看接口信息命令
    Router#sh int //只查看接口信息
    Router#:sh ip int brief  //查看所有接口的逻辑地址和开启状态
    Router#sh protocols //查看每个接口上第一层和第二层的状态
#### 验证配置
    使用一些常见的命令
    ping //查看连通性
    traceroute //节点跟踪
    telnet //没错，路由器也能用telnet
> <h2 id="9">管理Cisco互连网络</h2>
### Cisco路由器的内部组件
    Bootstrap //存储在ROM中的微代码，bootstrap用于在初始化阶段自启动路由器，它将启动路由器然后装入IOS
    POST(开机自检) //存储在ROM中的微代码，POST用于检测路由器硬件的基本功能并确定哪些接口当前可用
    ROM监控程序 //存储在ROM中的微代码，ROM监控程序用于手动测试和故障诊断(Debug?)
    微型IOS //Cisco调用RXBOOT或bootloader(引导装入程序),微型IOS是一个在ROM中可以启动接口并将Cisco IOS加载到闪存中的IOS，微型IOS也可以执行一些其他的维护操作
    RAM(随机存取存储器) //用于保存数据包缓冲，ARP高速缓存，路由表，以及路由器运行所需的软件和数据结构。running-config文件存储在RAM中，并且有些路由器也可以从RAM运行IOS
    ROM(只读存储器) //用于启动和维护路由器，存储POST和bootstrap程序以及微型IOS
    Flash memory(闪存) //路由器用于保存Cisco IOS，当路由器重新加载时，并不擦除闪存中的内容，它是一种由Intel开发的EEPROM(电可擦除只读存储器)
    NVRAM(非易失性RAM) //用于保存路由器和交换机配置，当路由器或交换机重新加载时并不擦除NVRAM中的内容，NVRAM中未存储IOS，配置寄存器存储在NVRAM中
    Configuration egister(配置寄存器) // 用于控制路由器如何启动,配置寄存器的值可用在show version命令输出结果的最后一行中找到，通常为0x2102，这个值意味着路由器从闪存加载IOS并告诉路由器从NVRAM调用配置
### 路由器启动顺序
```
    当路由器启动时，执行一系列步骤，称为启动顺序(boot equence),以测试硬件并加载所需的软件,步骤如下

    步骤:
        1.路由器执行POST(开机自检)，POST检查硬件，以验证设备的所有组件目前是可运行的，POST存储在ROM(只读存储器)中并从ROM运行
        2.bootstrap程序负责找到每个IOS程序的位置，然后加载该文件，默认情况下所有Cisco路由器都从闪存加载IOS软件
        3. IOS软件在NVRAM中查找有效的配置文件.此文件称为startup-config,只有当管理员将running-config文件复制到NVRAM中时才会产生该文件,新的ISR路由器中有一个预先加载的小型startup-config
        4.如果NVRAM中有startup-config文件，路由器目前是可操作的，如果NVRAM中没有startup-config文件，路由器将向所有进行载波检测(carrier detect,CD)的接口发送广播，查找TFTP主机以便寻找配置，如果没有找到
            (一般情况下都不会找到)，路由器将启动setup mode(设置模式)进行配置
```
### 管理配置寄存器
```
    所有Cisco路由器都具有一个位于NVRAM种的16位软件寄存器，默认情况下配置存储器设置为从闪存加载Cisco IOS，并且从NVRAM查找并加载startup-config文件
    
    配置寄存器(16位，从左到右为 15 -> 0)
        15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
        0  0  1  0  0  0  0 1 0 0 0 0 0 0 1 0   //这就是Cisco路由器的默认配置 0x2102（4位一组）

        每个位之间的作用
        位  十六进制
        0~3 0x000~0x000F //启动字段
            00 ROM监控模式  若要启动时采用ROM监控模式，将配置寄存器的值设置为2100，必须用b命令来启动路由器，路由器将显示rommon>作为提示
            01 从ROM启动映像文件    若要启动存储在ROM中的IOS映像文件，将配置寄存器的值设置为2001，路由器将显示router(boot)>作为提示
            02~0F 指定默认启动文件名 任何从2102到210F的值告诉路由器使用NVRAM种指定的启动命令
        6   0x0040 //忽略NVRAM内容
        7   0x0080 //启用OEM位
        8   0x101 //禁用中断
        10  0x0400 //ip广播全为零
        5、11~12    0x0800~0x1000 //控制台线路速率
        13  0x2000 //如果网络启动失败，则启动默认ROM软件
        14  0x4000 //IP广播不包含网络号
        15  0x8000 //启用诊断信息并忽略NVRAM内容

    检查当前配置寄存器的值
        Router#sh version //sh ver,这个命令会给出信息的配置寄存器的值
    
    修改配置寄存器
        可以通过修改配置寄存器的值来修改路由器如何启动(在修改配置寄存器之前，一定要了解当前配置寄存器的值)
        通过config-register命令修改配置寄存器，例如
        Router(config)#config-register 0x2101 //从ROM加载IOS
        Router(config)#reload
        Router(boot)#sh flash //用这个命令可以看到准备运行的闪存中的IOS，不过我们告诉路由器从ROM加载，所以它会显示主机名为(boot)
        Router(boot)#config t
        Router(boot)(config)#config-reister 0x2102
        Router(boot)#reload
```
### 恢复口令
```
    忘记口令，导致无法连接路由器

    1.启动路由器,按下CTRL + Break //启动路由器并按下这个键，执行中断，进入ROM监听模式
    2.rommon1>config-register 0x2142 //设置位6为1，忽略NVRAM内容
    3.rommon2>reset
    4.copy startup-config running-config
    5.config t
    6.enable secret admin
    7.config-registeer 0x2102
```
> <h2 id="10">IP路由</h2>
### 主动路由协议和被动路由协议之间的不同
    主动路由协议
        主动路由协议是路由器在互联网上动态寻找所有网络，并确保所有路由器拥有相同路由表的协议，主动路由协议基本上就是决定数据通过互联网络最优路径协议(RIP,RIP2,EIGRP,OSPF)
    被动路由协议
        被动路由协议是用来发送用户数据通过互联网络的，它可行的前提是建立在主动路由协议的基础上的，只有当所有路由器了解了所有网络，才能做到路由数据。(IP,IPv6)
### 路由基础
    通过使用路由器将WAN网络和LAN网络连接成一个互联网络，然后再给这个互联网络上的所有主机配置逻辑网络地址(IP地址)，这样主机之间就可以在这个互连网络进行互相通信了

    路由:数据包从一台设备通过网络发往另一台处在不同网络上的设备，路由器并不关心这些主机，它们只关心网络和通向每个网络的最佳路径，目的主机的逻辑网络地址是用来保证数据包可以通过路由网络到达目的网络，
        接着主机的硬件地址用来将数据包从路由器投递到目的主机。
    
    要完成对数据包的路由，路由器必须至少了解以下内容:
        * 目的地址
        * 相邻路由器，并可以从那里获得远程网络的信息
        * 到所有远程网络的可能路由
        * 如何维护并验证路由信息
    
    路由器可以从相邻的路由器或从管理员那里认识远程网络，之后路由器需要建立一个描述如何寻找远程网络的路由表(一张网络地图)，如果网络是直接与路由器相连，那么路由器自然就知道如何到达这个网络，
    如果网络没有直接与它相连，路由器必须通过学习来了解如何到达这个远程网络，所采用的方法只有两种:
        静态路由:必须由人来手动输入所有网络位置到路由器中
        动态路由:在一台路由器上运行的协议将与相邻路由器上运行的相同协议之间进行通信，然后这些路由器会更新各自对整个网络的认识并将这些信息加入到路由器表中去。
                如果在网络中有一个改变出现，动态路由协议将自动将这个改变通知给所有的路由器，但是如果使用的静态路由，就需要管理员手动添加了，在一个大型网络中同时使用动态和静态路由是很常见的事情
    
    查看路由表
    Router#sh ip route
### IP路由选择过程
    IP的路由处理是一个相当简单并没有多大变化的过程，它与网络的大小无关
![alt IP路由过程](./img/IP路由过程.png)
```
    主机A:172.16.10.2
    主机B:172.16.20.2
    (172.16.10.2):ping 172.16.20.2

    1.因特网控制报文协议(ICMP)将创建一个回应请求数据包(在它的数据域中只包含有字母)
    2.ICMP将把这个有效负荷交给因特网协议(IP),然后IP协议会创建一个数据包，这时，这个数据包将包含源IP地址,目的IP地址和值为0x01的协议字段，当数据包到达目的地时，所有这些内容会告诉接收方主机，它应该把这个有效负荷交给ICMP处理
    3.一旦数据包被创建，IP协议将判断目的IP地址是否处在本地网络中，还是处在一个远程网络上
    4.（在这里IP协议判断这是一个远程请求）这个数据包需要被转发到默认网关，这样，这个数据包才会被路由到远程网络，Windows注册表将被使用，以查找配置的默认网关
    5.主机A的默认网关被配置为172.16.10.1，要能够发送这个数据包到默认网关，必须要知道路由器的Ethernet0接口(172.16.10.1，E0)的硬件地址，只有知道了要发送的接口硬件地址，数据包才可以被下传给数据链路层并成帧，然后发送给与172.16.10.0网络连接的路由器接口(在本地局域网上，主机只可以通过硬件地址来进行通信，需要理解主机A要与主机B通信，它必须将数据包发送到本地网络中默认网关的MAC地址处)
    6.接着，检查ARP缓存，查看一个默认网关的IP地址是否已经被解析为硬件地址
        (1) 已解析
            数据包被释放，传送到数据链路层并成帧(目的方的硬件地址也同数据包一起下传至数据链路层，注意这里的目的放硬件地址是路由接口的MAC地址)
        (2) 未解析
            这个硬件地址在主机的ARP缓存表中没有被解析的话，它就会发送一个ARP广播到当前网络，寻找172.16.10.1的MAC地址，路由器会响应这个请求并提供E0的硬件地址，然后主机将这个地址缓存
    7.一旦这个数据包和目的方的硬件地址被交付给数据链路层，局域网驱动器将用来提供媒体访问，以通过所用类型的局域网(这里是以太网)，一个数据帧将产生，使用控制信息来封装此数据包，在这个帧中包含有目的方和源方的硬件地址，及以太网类型字段(这个字段里描述的是交付此数据包到数据链路层的网络层协议)，在这里这个协议为IP协议，在这个帧的结尾处是被称为帧校验序列(FCS)的字段，它是装载循环冗余校验(CRC)计算值的区域，这时候数据帧还需要查找一些信息，即主机A的硬件MAC地址，以及作为目标方的默认网关的硬件地址(注意这里不是远端主机的MAC地址)
    8.一旦完成帧的封装，这个帧将被交付到物理层，以一次一位的方式发往物理媒体
    9.此冲突域中的每台设备将接收这些位，并重组成帧，它们都将运行CRC并核对保存在FCS，如果两个值不相匹配，此帧将被丢弃
        (1)如果这个CRC值相吻合(在这里是路由器E0接口)，那么就核查目的方的硬件地址，检查它们是否也匹配
        (2)如果匹配的话，那么路由器将查看以太网类型的字段，了解在网络层上使用的协议
    10.数据包从帧中抽出，然后这个帧剩下的部分被丢弃，再把数据包传送给以太网类型字段中列出的上层协议，在这里是传递给IP协议
    11.IP会接收这个数据包，并检查其IP目的地址。由于数据包的目的地址与接收路由器所配置的任一地址不相匹配，路由器将会在路由表中查看目的IP网络的地址
    12.此路由器表中必须包含有网络172.16.20.0的表项，否则此数据包将被立即丢弃，然后一个携带有"destination network unavailable"信息的ICMP包将被发送回源方设备
    13.如果路由器的确在它的路由表中查找到了目的方的网络，数据包将被交换到输出接口，在这里是E1接口，由于在这个网络中两个网络都是直接连接，所以没必要使用主动路由协议
    14.路由器将交换此数据包到Ethernet1的缓冲区内
    15.E1缓冲区需要了解目的方主机的硬件地址，它首先检查ARP缓存，则这个数据包和这个硬件地址将被传送到数据链路层以便组成帧
        Router>show ip arp //查看路由ARP缓冲
        Router>show ip route //查看路由表
        
        * 如果硬件地址没有被解析，路由器将从E1发送一个ARP请求，查找172.16.20.2的硬件地址，主机B会使用它的硬件地址来进行响应，然后这个包和硬件地址都会被发送到数据链路层以组成帧
    16.数据链路层将使用这个目的方和源方的硬件地址，及以太网的类型字段和处于帧尾部的FCS字段来创建一个帧，将这个帧传送到物理层，并以一次一位的方式发送到物理媒体上
    17.主机B会接收到此帧并立即运行CRC，如果运算结果与FCS字段中的内容相匹配，这个目的方的硬件地址将被检查，如果主机发现是匹配的，随后将检查以太网类型字段中的值，判断数据包上传给网络层的什么位置。
        每台设备接收到数据包后都有一个判断流程:
            CRC检测 》 目的方的硬件地址 》 以太网类型字段值(判断交给网络层哪个协议处理) 》 (如果是IP协议)检测目的方IP地址
    18.在网路从，IP会接收这个数据包，并检查其目的方的IP地址，由于它们是匹配的，数据包的协议字段将被检查，以了解此有效负荷应该交给谁。
    19.这个有效负荷会被交付给ICMP，它将知道这是一个回应请求，ICMP会应答这个请求，通过即刻丢弃这个数据包并随后产生一个新的有效负荷来作为回应应答
    20.随后创建的数据包中将包含有源方和目的方的地址，协议字段和有效负荷。现在目的方设备为主机A
    21.前面被走过的发送步骤将在被走一遍，这不过这次发送方变成了B，所以下面就不写了

    注意:
        1.这两个主机之间发送数据包时，所使用的目的方硬件地址是默认网关的以太网接口，这里因为数据帧是不可以直接被发往远程网络的，它只有先发送到本地网络上，而且去往远程网络的数据包必须要通过默认网关的转发
        2.主机中的ARP缓存地址永远都是本地网络中的MAC地址，这个地址绝对不会跨路由
```
[回到顶部](#menu)