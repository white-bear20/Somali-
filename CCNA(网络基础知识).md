<style>
    body{
        background-color:#7ce8b9;
    }
</style>
# CCNA网络基础知识学习
*内容来源于《CCNA学习指南中文版》,因为这本书里面的知识都很基础，故可以作为基础知识，在这里可能会更注重于一些实践的东西，而不是纯理论*

<h2 id="menu">目录</h2>

* ### [网络模型](#1)
    * 最早的简单网络
        * 集线器
        * 冲突域
        * 广播域
        * 通信过程
    * 划分一个新的网络
        * 使用交换机进行网络分段
    * 互联网最小模型
* ### [OSI七层模型](#2)
    * OSI七层模型简介
    * 应用层
    * 表示层
    * 会话层
    * 传输层
        * 简单介绍传输层面向连接协议(TCP)
    * 网络层
        * 在网络层当中有两种类型的包：数据包 & 路由更新包
        * 路由表
        * 关于路由器的一些知识
    * 数据链路层
        * IEEE Ethernet的数据链路层下的两大子层
        * 交换机
    * 物理层
        * 以太网组网
        * 以太网的数据链路层
        * 以太网寻址
        * Ethernet帧
* ### [数据封装](#3)
* ### [Cisco3层分层模型](#4)
* ### [进制转换](#5)
    * 2  -> 10
    * 10 -> 2
    * 10 -> 16
    * 16 -> 10
    * 2 <-> 16
* ### [TCP/IP简介](#6)
    * 应用层
        * Telnet
        * FTP(文件传输协议)
        * NFS(网络文件系统)
        * SMTP(简单邮件传输协议)
        * SNMP(简单网络管理协议)
        * DNS(域名服务)
        * DHCP/BootP
    * 传输层
        * 传输控制协议(TCP)
        * 用户数据报协议(UDP)
        * TCP和UDP功能对比
    * 网络层
        * 因特网协议(IP)
        * IP首部
        * 因特网控制报文协议(ICMP)
        * 地址解析协议(ARP)
        * 逆向地址解析协议(RARP)
        * 局域网通信理解
        * 实例
        * IP寻址
            * IP术语
            * 分层IP寻址
            * 5类IP地址
            * 私有地址
* ### [子网](#7)
***

> <h2 id="1">网络模型</h2>
### 最早的简单网络
    主机通过集线器互连
#### 集线器
    关于集线器这种网络设备，可以把它理解为一个扩展接口，例如我们电脑只有一个有线网卡，那么理论上，我们只能连接一台主机，但是集线器上可能有很多接口，那么我们都把许多主机的网线插到集线器上，那么我们就相当于连接了插入其他接口的主机，这就形成了一个网络。

    集线器工作在第二层，所以是只能在局域网使用，并且这个网络中会有一个冲突域和一个广播域
![alt 集线器](./img/集线器.png)
#### 冲突域
    这里先简单说一下什么是冲突域，等到后面有写广播以及ARP的时候或许更能理解，在局域网中使用的是广播通信，在同一时间是只能发送一条信息的，假设两个主机同时发出了一条信息，那么就会产生冲突，结果就是导致谁也发不了信息，这就是冲突域，而且一个网络中的主机越多，冲突域也就越大，发送冲突的可能性也就越高，当然这是有解决方法的，有可以划分冲突域的网络设备
#### 广播域
    二层通信用的就是广播，所谓的广播域就是一个局域网的通信范围，例如这个局域网有30台主机，那么这30台主机就处在一个广播域，也就是说只要在这个网络中发送广播包，它们都能收到，广播域也有网络设备能划分（三层网络设备）
#### 通信过程
    我的IP(192.168.0.2)
    东哥IP(192.168.0.3)
    我现在想和东哥通信，那么我首先要做的是要获取东哥的MAC地址(因为局域网通信用的不是IP，而是MAC地址)
        1.发送广播包(广播的IP是192.168.0.255,MAC是ff:ff:ff:ff:ff:ff,IP可能是随着网段不同会变化，但是MAC是固定的)，内容为192.168.0.3是谁
        2.在这个网络每台设备都会接到这个广播包，然后进行对比，当东哥接到这个广播包后，发现是在找自己，他就会回应这个包(向192.168.0.2发送自己的MAC地址)
        3.我收到它的回应之后就有了它的MAC地址了，这样我们就能通过MAC进行通信了
        4.注意：在我获取到东哥的IP和MAC的时候，东哥也拥有了我的IP和MAC
### 划分一个新的网络
    通过集线器组成的网络我们可以知道，效率是非常低的，而且主机越多效率越低(因为冲突的存在),我们可以通过其他网络设备去划分网络(网络分段)，例如 路由器，交换机，网桥(早就不用了)，
    在继续之前我想先列出一下，在局域网中通信出现网络阻塞的原因
        1.广播域中有太多主机
        2.广播风暴
        3.组播
        4.低带宽
        5.使用了集线器
#### 使用交换机进行网络分段
    交换机这种设备也多用于局域网，进行二层通信(除非是三层交换机),它可以对冲突域进行划分，但是不划分广播域,从下图可以看到,使用交换机划分出了两个冲突域(交换机每个接口都是一个冲突域)，但是广播域就一个
    如果这个网络中的主机很多的话，那么就很容易形成网络堵塞。
![alt 交换机](./img/交换机.png)
### 互联网最小模型
    在这个网络模型中我们将使用路由器(三层设备),在因特网的网络互连中最常见的就是路由器，它的功能非常多(例如路由选址，端口转发),而使用路由器可以对广播域和冲突域进行划分，我对于局域网的理解为一个广播域就是一个局域网，那么划分了多个广播域的话就是多个局域网，这多个局域网之间通信就已经是在跨网段通信了，而因特网也是这样从小成多的连接组成的，所以我说这是互联网的最小模型。
![alt 路由器](./img/路由器.png)

> <h2 id="2">OSI七层模型</h2>
### OSI七层模型简介
    应用层(文件，打印，消息，数据库，应用服务)
    表示层(数据加密，压缩，转换)
    会话层(会话控制)
    传输层(端到端连接)
    网络层(路由选择)
    数据链路层(组帧)
    物理层(物理拓扑)
### 应用层
    应用层是用户与计算机进行实际通信的地方，实际上只有当马上要访问的网络的时候才会用到这一层，最简单的例子是使用浏览器查看本地文档时，这是与网络无关的，但是当我们要使用HTTP协议去请求文档，或者使用FTP进行下载的时候，就需要应用层来协助了，网络通信是软件的一部分，这点很重要，软件可以有很多功能，网络通信只是它的功能之一，

    应用层还负责识别并建立想要通信的计算机一方的可用性，并决定想要的通信是否存在足够的资源。
    应用层是实际应用程序之间的接口。
### 表示层
    表示层为应用层提供数据，并负责数据转换和代码格式化，这层就像一个翻译器
### 会话层
    会话层负责建立，管理和终止表示层实体之间的会话连接，这一层也在设备或节点之间提供会话控制，它在系统之间协调通信过程，提供三种不同的组织方式:
        单工
        半双工
        全双工
### 传输层
    传输层将数据分段并重组为数据流，传输层所提供的服务用于来自上层应用程序的数据进行分段和重组，并将它们组合为同样的数据流形式，它们可以提供端到端的数据传输服务，并且可以在互联网的发送方和接收方之间建立逻辑连接
    
    注：在传输层，“可靠的联网”指使用了 确认，排序，和流量控制。

    TCP(面向连接)传输和UDP(无连接)传输两种方式。

#### 简单介绍传输层面向连接协议(TCP)
    使用TCP协议进行通信之前，要先在通信的设备之间建立一条连接(逻辑连接)，而双方建立连接的这个过程，被称为TCP三次握手(是不是很熟悉)，当三次握手完成后，连接就建立了，也可以开始发送数据了，当数据传送完毕后，这个连接就会断开，关于这个细节后面学习的时候会讲到，现在就先了解一下

    面向连接的特征：
        1. 建立了一条虚电路(三次握手)
        2. 使用了排序
        3. 使用了确认
        4. 使用了流量控制(缓冲，宽口机制，拥塞避免)

    缓冲机制
        接收方在收到发送方要发送数据的请求后，会开辟一块缓冲区，接受的数据就放在缓冲区中来处理，如果缓冲区满了，就会向发送方发送请求，停止发送，等处理完之后又发送请求，可以发送。
    窗口机制
        双方商量好允许发送数据段的数量(字节),这个数量大小就是窗口大小，然后每次发送方就发送指定窗口大小数量的数据，例如
        发送方
            1 2 3 4
        接收方
            收到这4个包后，返回一个确认5，然后接收方收到5后，从第5个包开始发
        注：如果接收方主机不能收到应当确认的所有数据段，它就会减少窗口大小，来改进通信质量。
    
    实现可靠传输(确认机制)
        当发送一个数据段时候，发送方就会启动一个计时器，等带接收方的确认接收的响应包，如果计时器到了，这个包还没到，那么它就会重发。
### 网络层
    网络层(也叫第3层)负责设备的寻址,跟踪网络中设备的位置,并决定传送数据的最佳路径,这意味着网络层必须在位于不同地区的互联设备之间传送数据流。路由器(第3层设备)就工作在网络层,并在互联的网络中提供路由选择服务
    路由器的工作过程为:首先,当路由器的接口收到一个包时,路由器就检查其目的IP地址。如果包不是发给它的,它就在其路由表中查找目的网络地址。一旦路由器选择了一个外出接口(出口),包就被送到那个接口上并封装成帧,最后被送出本地网络。如果路由器在路由表中不能找到对应于包的目的网络的表项,它就丢弃该包。

#### 在网络层当中有两种类型的包：数据包 & 路由更新包
    数据包：在互联网中传递用户数据的，用来支持数据传输的协议叫被动路由协议，例如IP IPv6
    路由更新包：在互联网中，它用来向相邻路由器通告连接到网络的所有路由器的更新信息，发送路由器更新包的协议叫主动路由协议，例如RIP RIPv2，每台路由器上，路由更新包用来帮助和维护路由器表
#### 路由表
    网络地址    接口    度量 //三个信息组成
    
    网络地址:网络地址(Network addresses)它们是 与特定协议有关的网络地址。路由器必须为各种主动路由协议单独维护一张路由表.因为每个主动路由协议都采用不同的寻址方案(如IP、IPv6和IPX)来跟踪网络。可以把它想像为在某个特定的街道上，不同的居民说着不同的语言,因而有各种不同语言的街道标识。因此,如果街道上有美语、西班牙语和法语居民的话,街道标识就会同时用美语、西班牙语和法语表示出来。

    接口:当数据包被发送到特定的网络时,数据包将选择一个外出接口(出口)。

    度量:度量(Metric)指 到远程网络的距离。不同的主动路由协议采用不同的方式来计算距离。一些主动路由协议(即RIP)采用跳计数(它指的是包被传送到远程网络所经过的路由器的数量)，而其他一些主动路由协议采计数(它指的是包被传送到远程网络所经过的路由器的数量)，而其他一些主动路由协议采用带宽、线路延迟或嘀嗒数(为1/18秒)。用带宽、线路延迟或嘀嗒数(为1/18秒)。

#### 关于路由器的一些知识
    1.默认路由器不转发任何广播包，或组播包
    2.路由器可以使用逻辑地址，逻辑地址在网络层的报头中，用来决定将包转发到下一跳的路由
    3.路由器可以使用管理员创建的访问表来控制被允许进入或流出一个接口的包的安全性
    4.如果需要的话，路由器可以实现2层功能
    5.第三层设备(路由器)可以提供VLAN
    6.路由器可以提供QoS服务

### 数据链路层
    数据链路层提供数据的物理传输，并处理出错通知，网络拓扑和流量控制，这意味着在使用硬件地址的LAN中，数据链路层将保证信息被传送到正确的设备上，并将来着网络层的信息转为比特流的形式，方便物理层传输
    数据链路层将信息封装成数据帧，并添加定制报头，报头中包含了硬件形式的源地址和目的地址，这些被添加的信息围绕在原始信息的周围。

    数据链路层使用硬件寻找的方式，每次在路由器之间传送包时，它就在数据链路层被封装为带控制信息的帧，但这些控制信息将被接收方的路由器剥离，然后只保留原始的数据包，然后这个数据包又被封装成帧，这个过程会在每一跳中继续下去，直到数据包传输到正确的接收方主机，也就是说其实在传输过程中，数据包里面的MAC地址并不是不变的，而是每一跳都会被改变，具体行为是：当前路由抽离第二层信息，然后重新封装的时候发送方MAC会改成自己的目标MAC会改成下一跳路由的，如此重复

#### IEEE Ethernet的数据链路层下的两大子层
    介质访问控制(MAC)
        介质访问控制(Media Access Control,MAC)802.3它定义了数据包怎么在介质上进行传输，在共享同一个带宽链路中，对连接介质的访问是“先来先服务”，物理寻找在此处被定义，逻辑拓扑也在此处被定义，逻辑拓扑是什么？是信号通过物理拓扑的路径，线路控制，出错通知(不纠正),帧的传递顺序和可选择的流量控制都在这一子层实现
    逻辑链路控制(LLC)
        逻辑链路控制(Logical Link Control ,LLC)802.2 它 负责识别网络层协议,然后对它逻辑链路控制(逻辑链路控制)802.2它负责识别网络层协议，然后对它们进行封装。LLC报头告诉数据链路层一旦帧被接收到时,应当对数据包做何处理。它的工作原理是这样的，主机接收到帧并查看其LLC报头，以找到数据包的目的地，比如说，在网络层的IP协议，LLC子层也可以提供流量控制并控制比特流的排序。
#### 交换机
    对于第二层设备，它关注的是设备，而不是网络。
    
    透明桥接:
        二层设备内部会有一个过滤表，这个过滤表被创建之后，二层设备只将帧转发到目的硬件地址所指定的网段，如果目的设备与帧在同一网段上，二层设备将封锁帧，不让他被转发到其他网段，如果目的与帧在不同的网段上，帧就只被转发到那个网段
    
    交换机接口收到带目标硬件地址的帧，而且在交换机的过滤表中找不到这个目的硬件地址时，它将把该帧转发到所有相连的网段上，如果发送"神秘帧"的未知设备响应这个转发行动，交换机就会更新自己的过滤表，添加对比此设备的定位，但是如果发送的帧目的地址为广播地址，默认时交换机将转发所有的广播到每个相连的网段上。

    注：第二层设备传播广播可能会引起广播风暴，唯一的解决办法就是用路由器

### 物理层
    物理层的功能有两个：发送和接收比特流，比特流的值只能是1或0,这一层我不会写太多，因为我现在并不想太关注物理层面
#### 以太网组网
    以太网采用竞争型的介质访问方法，允许网络上所有的主机共享同一条链路的带宽。
    它采用了一种名叫    载波侦听多路访问(Carrier Sense Multiple Access with Collision Detect,CSMA/CD)的冲突检测技术,这是一种介质访问的控制方法，用来帮助网络上的设备均匀地分享带宽，而不会使两台设备同时在网络上传送数据。

    载波侦听多路访问:
        当网络中的不同节点同时传送数据包时，会不可避免的产生冲突，CSMA/CD就是用来解决这种冲突的
        当一台主机想要在网络中传送数据的时候，它首先会检查线路上是否有其他主机的信号正在传送，如果没有就先将自己的数据发送出去，并且不断的监听线路，以确信没有其他主机正在发送数据，并通知网段上其他所有的节点停止发送数据。作为Jam信号的响应，网络上的节点会在试图重新发送数据之前先等一会。退避算法会决定冲突主机什么时候可以重新发送数据，如果在试了15次之后还是产生冲突，试图发送数据的节点将超时。

        简单来说：
            当冲突发生
            Jam信号会让所有设备都知道发生了冲突
            冲突会激活随机退避算法
            以太网中每台设备都会等一小段时间，直到定时器到期
            定时器到期后，所有主机重新发送数据的机会是均等的
#### 以太网的数据链路层
    以太网数据链路层负责以太网寻址，通常称其为硬件寻址或MAC寻址。以太网也负责将从网络层接收下来的数据包组合成帧，并通过以太网连接介质访问的方法在本地网络上进行传输
#### 以太网寻址
    它采用了 介质访问控制(MAC)地址进行寻址，MAC地址被烧入每个以太网卡，所以MAC地址也叫硬件地址(可以伪造MAC地址),它采用了48位(6字节)的MAC地址,以16进制的格式表现，并且MAC地址可不是乱配的，它是有备而来
    前24位是组织唯一标识符(OUI)是由IEEE分配给单位组织的，每个单位组织依次被分配一个全局管理地址(24位/3字节)，对于厂家生产的每一块网卡来说，这个地址是唯一的(不能保证),
![alt MAC](./img/MAC地址.png)
    I/G
        值为0：表示这个地址实际上是设备的MAC地址，它可能出现在MAC报头的源地址部分
        值为1：表示这个地址是以太网中的广播地址或组播地址
    G/L(U/L)
        值为0：表示一个全局管理地址(由IEEE分配)
        值为1：表示一个在管理上统治本地的地址
    后面24为表示本地管理的或厂商分配的代码，由于这个限制的存在，所以每个厂商可以做的网卡数量是限制的
#### Ethernet帧
    数据链路层负责将位组合成字节，并将字节封装成帧，帧被用在数据链路层，从网络层传递过来的数据包被封装成帧，以根据介质访问的类型进行传输，以太网的功能就是使用一组称为MAC帧格式的位，在站点之间进行数据帧传输
    ，采用了循环冗余校验(CRC)进行差错检测
![alt Ethernet](./img/Ethernet.png)
    注:将一个帧封装到不同的类型的帧中，被称为隧道技术
    
    每个字段含义:
        前导:
            采用交替为1和0的模式，每个数据包的起始处提供5MHz的时钟信号，以允许接收设备锁定进入的比特流
            帧起始定界符/同步(Start Frame Delimiter,SFD/Synch)前导为7字节，SFD为1字节、
        DA(Destination Address,目的地址):
            它首先使用最低有效位(LSB)传送48位值，接收方使用DA来决定一个进入的数据包是否被传送往特定的节点，目的地址可以是单独的地址或者是广播或组播的MAC地址
        SA(Source Address, 源地址):
            SA是48位的MAC地址，用来识别发送设备，它首先使用LSB。在SA字段中，广播和组播地址格式是非法的
        长度/类型:
            802.3使用长度字段,但是Ethernet帧使用类型字段来识别网络层的协议。802.3不能识别上层协议，并且必须与专用LAN一起使用
        帧校验序列(Framee Check Sequence,FCS):
            FCS是位于帧末尾的字段，它是用来存放CRC的

> <h2 id="3">数据封装</h2>
    前面有说到七层模型，那么我们要发送的数据在通过每一层的时候都变成什么样子了呢?

    当主机跨越网络向其他设备传送数据时，就要进行数据封装，就是在OSI模型的每一层上加上协议信息，每一层只与接收设备上相应的对等层进行通信。
    为了实现通信并交换信息，每一层都使用了协议数据单元(protocol Data Units,PDU).在模型中的每一层，这些含有控制信息的PDU被附加到数据上，他们通常被附加到数据字段的报头中，但它们也可以被附加在数据字段的报尾中。
    在OSI模型的每一层，通过封装使每个PDU被附加到数据上，而且每个PDU都有特定的名称，其名称取决于在每个报头中所提供的信息。这种PDU信息只能由接收方设备中的对等层读取，在读取后，报头就被剥离，然后把数据交给上一层。
![alt 数据封装](./img/数据封装.png)

    添加的具体内容:
        传输层(数据段)
            源端口  目的端口 ... 数据
        网络层(数据包)
            源IP 目的IP 协议 ... 数据段
        数据链路层(帧)
            目的MAC 源MAC Ether-字段 数据包 FCS
        物理层(比特流)
    
    在实际传输时(跨网段)，帧会被解读，然后重新封装，MAC会更换，源MAC会变成封装帧的设备MAC，然后目标MAC会变成下一跳设备的MAC，但在这个过程中IP是不变的。

> <h2 id="4">Cisco三层模型分层</h2>
    Cisco定义了3个层次(逻辑)，每一层都有特定的功能
        核心层：骨干
        分配层：路由
        接入层：交换

> <h2 id="5">进制转换</h2>
### 2  -> 10
    从右往左开始，每位上的数字(0/1) * 2的n次方,n从0开始递增
    0100 -> 0 * 2^0 + 0 * 2^1 + 1 * 2^2 + 0 * 2^3 = 4
### 10 -> 2
    用10进制数除以2，得出一个商和余数，然后又除以2又得出商和余数，以此类推，然后逆序取值，不足位数的话就高位补0
![alt 十转二](./img/十转二.png)
### 10 -> 16
    16进制一般对应这两个字节，也就是4位一字，例如15的话也是表示0x0F,0x只是个修饰，表示是十六进制
    类似于10转2
![alt 十转十六](./img/十转十六.png)        
### 16 -> 10
    类似于2转10
    FF -> 15 * 16^0 + 15 * 16^1 = 255
### 2 <-> 16
    前面有说过4个比特位表示1个字，也就是一个十六进制位，所以这里有一个对照的转换表，而不通过计算
    二进制  十六进制
     0000     0
     0001     1
     0010     2
     0011     3
     0100     4
     0101     5
     0110     6
     0111     7
     1000     8
     1001     9
     1010     A
     1011     B
     1100     C
     1101     D
     1110     E
     1111     F
***

> <h2 id="6">TCP/IP简介</h2>
    TCP/IP协议(传输控制协议/因特网协议),这个协议的主要作用就是用来维持互联网通信的，TCP/IP协议有一个自己的四层模型，不过这个模型也是对应着OSI七层模型，如图
![alt TCP/IP四层与OSI七层对比](./img/osi_V_TCP-IP.png)
    TCP/IP这四层模型也叫DoD模型，下面开始简述各层的作用
### 应用层
    DoD模型下的应用层中包含了大量的协议，它集成了各种应用和功能来生成一个可以和OSI模型中对应的三个高层相对应的集合，待会下面也会简介一些协议
#### Telnet
    Telnet协议，可以模拟一个终端，它允许用户在远程客户端访问一台机器上面的资源，Telnet是通过在Telnet服务器上运行并且在客户端显示操作结果来实现控制的。
#### FTP(文件传输协议)
    文件传输协议顾名思义其实就是传输文件的协议，它可以应用再任意两台主机之间。但是FTP不仅仅是个协议，它同时也是一个程序，作为协议，FTP是被应用程序所使用的，而作为程序FTP是需要用户通过手动的方式来使用的，
    并且FTP协议允许执行对目录和文件的访问，还可以完成特定类型的目录操作(例如:将文件重新定位到不同的目录中)
    TCP通过与Telnet合作来完成对FTP服务器的登录操作，并在之后开始提供文件传输服务，但是再此之前，用户必须要登录才能开始传输，需要提供正确的账号和密码，但是也可以试试用anonymous来尝试登录。
#### NFS(网络文件系统)
    网络文件系统(NFS)允许一个系统在网络上与它人共享目录和文件
#### SMTP(简单邮件传输协议)
    简单邮件传输协议(SMTP)对应于我们普遍使用的被称为E-mail的应用
#### SNMP(简单网络管理协议)
   简单网络管理协议采集并使用一些有价值的网络信息，它通过从管理站定期或不定期地轮询网络上的设备来获取数据，并要求这些设备透露某些与管理相关的信息。
#### DNS(域名服务)
    域名解析
#### DHCP/BootP
    动态主机配置协议(DHCP)可以为主机分配IP地址，BootP也可以完成给主机分配IP的任务，但是它要求主机的硬件地址必须被手工输入到BootP表中，不过DHCP是自动分配的。
    DHCP可以提供以下服务:
        IP地址
        子网掩码
        域名
        默认网关
        DNS
        WINS信息
    DHCP的是无连接的，用的是UDP

### 传输层
    传输层做数据分段，以及指定好通信端口(1024号端口都是被指定了一些默认服务或应用，所以我们自己调用端口的时候最好使用1024后面的)，端口号是用来区分会话的(不然一个主机上许多进程通信，谁知道哪个包是给谁的呢),
#### 传输控制协议(TCP)
```
    TCP从应用程序获取大段的信息数据，然后将它分割成若干个数据段，TCP会为这些数据段编号并排序，这样的话再目的方的TCP协议栈才可以将这些数据段再重组成原来的数据结构，由于TCP采用的是虚电路的连接方式，这些数据段再被发送出去后，发送方的TCP会等待接收方的TCP给出一个确认性的答案，如果超时了还没有收到确认应答，数据段将被重发。

    虚电路:发送方的TCP协议会通知目的方的TCP协议去建立一个TCP连接，这就是所谓的虚电路，而这种通信也被称为面向连接，在这个连接的初始化过程中(三次握手)，双方的TCP层需要对接收方在返回确认应答之前，可以连续发送多少数量的信息达成一致(窗口大小)

    TCP数据段格式(TCP报头是一个20字节长的段，在带有选项时可以长达24字节)
```
![alt TCP首部](./img/TCP首部.png)
```
各个字段含义
    源端口号(2byte): 主机上应用发送数据的端口号
    目的端口号(2byte): 在目标主机上接收应用程序数据的端口号
    序列号(4byte): 用于将数据编排回原来正确的顺序或者用于对丢失或损坏的数据进行重传的编号
    确认号(4byte): 用于说明下一个所期望接收的TCP序号包
    数据偏移(1byte): 因为有选项这栏的存在，所以TCP报头的长度不是固定的，所以采用这个字段指出数据的开始的位置。
    保留(6bit): 总是被设置为0
    代码位(URG/ACK/PSH/RST/SYN/FIN,6bit): 提供用于建立及结束会话的控制功能
        URG:这个标记表示数据包比较紧急，要优先发送
        ACK: 只要当ACK为1时，确认号才会有用
        SYN: 用于建立会话，当SYN被标记为1时就表示这是一个建立连接的请求
        PSH: 这个被标记为1的话，表示这个包需要优先被读取
        RST: 这个被标记为1的话，表示TCP连接出现了问题，必须要释放连接
        FIN: 这个被标记为1的话，就表示数据传输完毕，可以释放TCP连接了。
    窗口(2byte): 发送方将允许的发送窗口尺寸，用八进制形式表示
    校验和(2byte): 存储循环冗余校验(CRC)，这个字段用于检测报头或者数据是否被改变
    紧急指针(2byte): 只有当URG为1时，里面的数据才有效，它指出了数据包中需要紧急处理数据的尾部在哪
    选项(0/4byte): 没有选项时为0，当有选项时就要占用4字节，不够大小也要用0来填充
    数据: 指被传送到传输层的TCP协议的数据
```
#### 用户数据报协议(UDP)
```
    UDP非常不可靠，因为它不对需要发送的数据段进行排序，而且不关心这些数据段到达目的地的顺序，并且发送完后就完事了，不会关心是否送到，但是UDP的效率会比较高
    UDP不会创建虚电路，所以它又称为无连接的协议

    UDP数据段格式(如果没有数据就是8字节)
```
![alt UDP数据首部](./img/UDP首部.png)
```
各个字段含义
    源端口号(2byte): 主机上应用发送数据的端口号
    目的端口号(2byte): 在目标主机上接收应用程序数据的端口号
    长度(2byte): UDP报头和UDP数据的长度
    校验和(2byte): UDP报头和UDP数据的长度
    数据: 上层数据
```
#### TCP和UDP功能对比
```
    TCP              UDP
    排序             无序
    可靠            不可靠
   面向连接         无连接
    虚电路          低开销
    确认            无确认
 窗口流量控制   没有窗口或流量控制
```

### 网络层
#### 因特网协议(IP)
    因特网协议(IP)实际上就是网络层，其他的协议都是建立在这个协议基础上建立起来的。
    IP关注每个数据包的地址，通过使用路由表，IP可以决定一个数据包将发送给哪一个被选择好的后续最佳路径。
#### IP首部
![alt IP首部](./img/IP首部.png)
```
首部各字段含义(一般是20字节):
    版本(4bit): IP版本号
    首部长度(4bit): 报头的长度
    区分服务(1byte): 服务类型描述数据将如何被处理，前三位表示优先级
    总长度(2byte): 包括报头和数据的数据包长度
    标识(2byte): 唯一的IP数据包值
    标志(4bit): 说明是否有数据被分段
    片偏移(12bit): 如果数据包在装入时帧太大了，需要进行分段和重组，分段功能允许在因特网上存在有不同大小的最大传输单元(MUT)
    生存时间(1byte): TTL，存活期是在数据包产生时建立在其内部的一个设置，如果这个数据包在这个TTL到期时仍没有到达目的地，它就会被丢弃，这个设置将防止IP包在寻找目的地的时候在网络中不断循环 
    协议(1byte): 上层协议的协议号，是十六进制
        协议            协议号
        ICMP             1
      IP in IP(隧道)     4
        TCP              6
        IGMP             9
        UDP              17
        EIGRP            88
        OSPF             89
        IPv6             41
        GRE              17
      第2层隧道(L2TP)     115
        

    首部检验和(2byte): 只针对报头的循环冗余校验(CRC)
    源地址(4byte): 发送方的IP地址
    目的地址(4byte): 接收方的IP地址
    选项(4byte): 用于网络检测，调试，安全以及更多内容
```
#### 因特网控制报文协议(ICMP)
    因特网控制报文协议(ICMP)工作在网络层，它被IP用于提供许多不同的服务。ICMP是一个管理性协议，并且也是一个IP信息服务的提供者，它的信息是被作为IP数据报来传送的。
    ICMP包的特性:
        能为主机提供有关网络故障的信息。
        被封装在IP数据包内。
    我们常使用的ping命令使用的就是ICMP协议，下面是一些ICMP相关的常见的事件或信息。
        目的不可达:路由器不能在向前转发数据报。
        缓冲区满:路由器用于接收输入数据报的内存缓冲区已经满了，它将会使用ICMP向外发送这些信息，直到拥塞解除。
        ping:检测计算机物理和逻辑连接的连通性。
        Traceroute:Traceroute通过使用ICMP的超时机制来发现一个数据包在穿越互联网络时它所经历的路径,(cmd命令为:tracert)
#### 地址解析协议(ARP)
    地址解析协议(ARP)可用由已知主机的IP地址在网络上查找到它的硬件地址，它的工作过程是这样的:当IP有一个数据报需要发送时，他必须要告诉某个网络访问协议，接收方主机在本地网络上的硬件地址，如果IP不能在ARP缓存中找到目的方主机的硬件地址，那么它就会使用ARP去获取这个地址

    ARP会通过发送一个广播数据包来询问本地的网络，要求使用这一指定IP地址的计算机应答其自身的硬件地址。因此可以说ARP能够实现软件(IP)地址到硬件地址的转换，并且能够通过广播判断出它在局域网上的位置

    简单来说 ARP的功能就是 IP -> MAC 的转换
![alt ARP包](./img/ARP包.png)
#### 逆向地址解析协议(RARP)
    当一台主机只有MAC地址而不知道自己的IP地址的时候，它可以通过发送广播包的办法，询问自己的IP地址是多少，这时候拥有RARP服务的主机就会响应这个请求，并告诉它，它的IP
#### 局域网通信理解
    前面有说ARP而在更早之前我也说过，局域网通信使用的是广播，和MAC地址，IP在这里面的作用似乎不那么重要，但是却又不可缺少

#### 实例
实验环境
![alt 环境](./img/LAN1.png)
```
    这个局域网内有三台主机，一台交换机。

    通信流程:
        假设PC0要和PC1进行通信，那么这里使用ping命令来进行通信,但是前面就有说过，局域网内不用IP寻址，使用 ping 192.168.0.3,
        那现在PC0就会发一条广播包，询问谁是192.168.0.3(这个时候PC0和PC1的ARP解析表也是空的)
        (可以通过arp -a命令查看)
```
![alt arp-a](./img/arp-a.png)
```
    然后广播包发出来之后，所有主机都收到这个询问包，然后和自己的IP对一下，PC1拿到这个包和自己一对，发现这个孙子找的是自己，然后就回了一个响应包，你爷爷在此(附上自己的MAC地址)，
    然后当PC0接到这个包之后，心想好家伙这么嚣张，这能忍？，必须的记住它，然后就往自己的ARP缓存表中添加了一条映射关系 [192.168.0.3 它的MAC地址],有了这条记录之后，
    它每次找PC1只需要查找自己的ARP缓存表就能知道它的MAC地址，下次就能直接和PC1通信了，在这个过程中，PC1也会在自己的ARP缓存中记住PC0的IP和MAC地址映射。
```
![alt LAN2](./img/LAN2.png)
```
    在这个过程中，交换机也会对这两者的IP地址和MAC地址映射进行存储，之前就说过交换机有缓存表，而且在这个网络中数据包全是通过交换机来进行发送的，所以下次在有人找这两货的时候交换机就知道要发给哪个接口了。
```
```
IP地址在局域网中的作用似乎不那么重要，但是却又不可缺少这句话如何理解，理论上上来说，通过MAC地址通信那么IP地址有没有都行的，但是为什么又说它不可缺少呢，我觉得是对于用户来说，
就拿我们来说，如果没有IP地址，那么我要Ping，去Ping谁呢？所以是我们需要用IP地址去映射MAC地址进行通信，而不是局域网通信需要IP地址

注：这里对局域网的定义仅仅是一个段，如果有人说 192.168.0.0是一个局域网 192.168.1.0也是一个局域网，那么它们之间通过路由连接是一个更大的局域网，但是它们用到了IP。
```
#### IP寻址
    IP地址是IP网络上每台计算机的数字标识符，它指明了在此网络上某个设备的位置，IP地址是一个软件地址，而不是硬件地址(被硬编码烧录到网卡中)，并且主要用于在本地网络上定位主机，IP寻址允许在某网络上的主机与另一个不同网络上的主机进行通信，并在此过程中无需考虑这两台主机所在的具体局域网的类型差异
##### IP术语
    在学习IP寻址之前，了解一些IP术语

    位: 指bit位，要么是0要么是1
    字节: 一个字节一般是为8位，但是也有说可以是7位，具体是取决于是否使用了检验位
    八位位组: 就是8位
    网络地址: 它是在将数据包发送到远程网络的路由中使用的名称，例如 15.0.0.1
    广播地址：被应用程序和主机用于将信息发送到网络上所有节点的地址
##### 分层IP寻址
    一个IP地址由32位组成，这些位通常被分割为4个部分，一个部分8位，它有3种不同的表现形式
    点分十进制:172.16.30.56
    二进制:10101100.00010000.00011110.00111000
    十六进制:AC.10.1E.38

    对于IP地址的分层，它是这样分的
        网络地址    子网地址    主机地址 //这些地址具体占多少位，怎么划分不固定，看人
        或者是
        节点地址
    网络地址:
        网络地址唯一指定了每个网络，同一网络中的每台计算机都共享相同的网络地址，并用它作为自己IP地址的一部分，例如在 192.168.0.1中,192.168.0就是这个网络的地址.
    主机地址:
        标识主机的地址，例如上面的192.168.0.1中的0.1就是主机地址
    节点地址:
        在一个网络中用来标识每台计算机的，它是一个唯一的标识符，这个地址的节点部分必须唯一
##### 5类IP地址
```
    A类 网络地址 主机地址 主机地址 主机地址
    B类 网络地址 网络地址 主机地址 主机地址
    C类 网络地址 网络地址 网络地址 主机地址
    D类 组播
    E类 研究
```
```
    A类:
        第一部位的第一位必须是0，用来标识这是一个A类地址，那么它的最大值也只能是7个1，也就是说A类地址的网络地址只能是,0~127
    B类:
        第一部分的第一位必须是1，第二位必须是0，也就说它最小是 1000 0000 最大是 1011 1111,也就是说B类地址的网络地址只能是,128~191
    C类:
        按照规律，前两位必须是1，第三位必须是0，最小:1100 0000 最大 1101 1111,也就是说C类地址的网络地址只能是192~223
    D类:
        224~239,用于组播
    E类:
        240~255用于科学实验

    D类和E类这里不考虑
```
```
    在A,B,C类中有一些特殊地址被保留下来有一些特殊含义，下面记录一下

    网络地址全为0                   指这整个网络或者分段
    网络地址全为1                   指全部网络
    127.0.0.1-127.255.255.255      被保留用于环回测试，指向本地，用这个地址发送的测试数据包不会产生网络流量
    主机地址全部为0                 指网络中任意一台主机
    主机地址全部为1                 指当前网络中所有节点
    255.255.255.255                在当前网络上进行广播的地址
    0.0.0.0                        指向默认路由，也可以指任意网络
    10.0.0.1-10.255.255.255        私有地址
    172.16.0.1-172.31.255.255      私有地址
    169.254.0.0-169.254.255.255    保留地址，如果你的IP地址是自动获取IP，但是网络上又没找到DHCP服务器，这时候就会从这里面随机获取一个地址
    192.168.0.1-192.168.255.254    私有地址
```
##### 私有地址
    私有地址是用来构建私有网络的，它们不属于公网IP，无法通过路由进入因特网，1来为了安全考虑，2来也是为了节省宝贵的IP地址，我们现在的上网环境多数都依赖于NAT这种转换技术，后面也会说到

> <h2 id="7">子网</h2>
### 如何创建子网
    要创建子网，就需要从IP地址的主机部分中借出一定的位，并保留它们用来定义子网地址，这意味着用于主机的位减少，所以子网越多，可用于定义主机的位就越少

    记住2的幂
        2^1 = 2
        2^2 = 4
        2^3 = 8
        2^4 = 16
        2^5 = 32
        2^6 = 64
        2^7 = 128
        2^8 = 254
        2^9 = 508
        2^10 = 1024
### 子网掩码
    为了保证所配置的子网地址可以工作，网络中的每台计算机都必须知道自己的主机地址中的哪一部分是被用来表示子网地址的。这可以通过在每台计算机上指定一个子网掩码来完成
    子网掩码是一个32位的值，通过它接收IP数据包的一方可以从IP地址的主机号部分中区分出子网ID号地址

    使用1和0组合来创建一个32位的子网掩码，子网掩码中的1位置表示网络或子网的地址部分，不是所有的网络都需要子网掩码，有一些主机使用默认的子网掩码
    A类默认 255.0.0.0 //在这种掩码下，网络号相同是一个网段，例如 10.0.0.1 和 10.1.1.1 是在同一个网段
    B类默认 255.255.0.0 //同上，只不过B类的网络号是2个点位 172.16.1.1 和 172.16.2.2 是一个网段 和 172.20.20.20不是同一个网段
    C类默认 255.255.255.0 //C类的网络号是3个点位 192.168.1.1 和 192.168.1.2是一个网段 和 192.168.2.1不是一个网段

    还有另外一种表示子网划分的方法，就是使用/,例如C类 192.168.0.0/24  = 192.168.0.0 255.255.255.0,后面这个24就表示有多少位被设置为1，也就是网络位
    由于IP地址有4个字节也就是32位，所以它最大能被设置为1的位数只有30位，因为必须为主机位保留至少2位
    A类只能用 /8~/15表示
    B类只能用 /16~/23表示
    C类只能用 /24~/30表示

### C类地址的子网划分
    要划分子网就是占用主机位，C类地址就还有8位主机位，那么它最多只能被占用6位(因为最少保留2位主机位),这个过程一定是从左往右开始的，而且中间不能跳过某些位
    也就是说C类的子网掩码只能是
    1000 0000 = 128 /25
    1100 0000 = 192 /26
    1110 0000 = 224 /27
    1111 0000 = 240 /28
    1111 1000 = 248 /29
    1111 1100 = 252 /30
    
    如何计算出划分了多少子网，以及每个子网有多少主机，还记得之前说的2次幂吗
    多少子网？ 2^x = 子网数目 x=掩码中1的数量
    每个子网多少主机？ 2^y - 2 = 主机数量 y=掩码中0的数量,-2是因为有一个子网地址，广播路由地址
    例如 /25，才1个1，所以就划分了两个子网，而有7个0，所以有 2^7 -2 = 126
    
    哪些子网是合法的呢？
    256 - 子网掩码 = 块的大小
    256 - 128 = 128，即0是一个子网，128又是一个子网

    这些子网中的广播地址又是什么呢?
    每个子网中的广播地址是紧邻下一个子网的地址

    192.168.0.0 255.255.255.128
    192.168.0.1-127 是一个网段，广播地址是192.168.0.127，子网地址是 192.168.0.0
    192.168.0.128-255 是一个网段，广播地址是192.168.0.255，子网地址是 192.168.0.128
#### 练习
* 192.168.1.1 255.255.255.192 (/26)
    几个子网? 2^2 = 4
    每个子网多少个主机? 2^6 - 2 = 62 
    有效子网? 0 64 128 192
    每个子网的广播地址和子网地址
        子网地址    广播地址
     192.168.1.0  192.168.1.63
     192.168.1.64 192.168.1.127
     192.168.1.128 192.168.1.191
     192.168.1.192 192.168.1.255
* 192.168.1.1 255.255.255.224 (/27)
    几个子网? 2^3 = 8
    每个子网多少个主机? 2^5 - 2 = 30 
    有效子网? 0 32 64 96 128 160 192 224
    每个子网的广播地址和子网地址:省略
* 192.168.1.1 255.255.255.240 (/28)
    几个子网? 2^4 = 16
    每个子网多少个主机? 2^4 - 2 = 14
    有效子网? 0 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240
    每个子网的广播地址和子网地址:省略
* 192.168.1.1 255.255.255.248 (/29)
    几个子网? 2^5 = 32
    每个子网多少个主机? 2^3 - 2 = 6
    有效子网? 0 8 16 24 30 ......
    每个子网的广播地址和子网地址:省略
* 192.168.1.1 255.255.255.252 (/30)
    几个子网? 2^6 = 64
    每个子网多少个主机? 2^2 - 2 = 2
    有效子网?0 4 8 12 16.......
    每个子网的广播地址和子网地址:省略
### B类地址子网划分
经过前面的C类练习，现在进行进阶，B类可能出现的子网掩码有
    255.255.0.0 /16
    255.255.128.0 /17
    255.255.192.0 /18
    255.255.224.0 /19
    255.255.240.0 /20
    255.255.248.0 /21
    255.255.252.0 /22
    255.255.254.0 /23
    255.255.255.0 /24
    255.255.255.128 /25
    255.255.255.192 /26
    255.255.255.224 /27
    255.255.255.240 /28
    255.255.255.248 /29
    255.255.255.252 /30
    等掩码到了/24之后这个B类地址就和C类地址很类似了
#### 划分练习
* 172.16.0.0 255.255.128.0 (/17)
    几个子网? 2 ^ 1 = 2
    每个子网多少个主机? 2^15 - 2 = 32766
    有效子网? 172.16.0.0 172.16.128.0
    每个子网的广播地址和子网地址:
        子网地址    广播地址
    172.16.0.0     172.16.127.255
    172.16.0.128   172.16.255.255
* 172.16.0.0 255.255.192.0 (/18)
    几个子网? 2^2 = 4
    每个子网多少个主机? 2^14 - 2 = 16382
    有效子网?0.0 64.0 128.0 192.0
    每个子网的广播地址和子网地址:省略
* 172.16.0.0 255.255.224.0 (/19)
    几个子网? 2^3 = 8
    每个子网多少个主机? 2^13 - 2 = 8190
    有效子网? 0.0 32.0 64.0 96.0 128.0 160.0 192.0 224.0
    每个子网的广播地址和子网地址:省略
### A类地址子网划分
这个就不写了，和B,C基本一样的方法
### 可变长度子网掩码(VLSM)
    有类路由:无论是RIPv1还是IGRP路由选择协议，都没有为子网信息设置字段，因而子网的信息都会被丢弃，这就意味着，如果一个运行RIP的路由器设置了某个数值的子网掩码，它会假定在这个有类地址区域内的所有端口都
    使用了相同的子网掩码，如果在这个网络中混合使用了不同长度的子网掩码，这个网络就无法正常工作

    无类路由:使用RIPv2，EIGRP或OSPF等路由选择协议来使用VLSM，这样可以混合使用不同长度的子网掩码，可以节省大量IP
    通过VLSM可以将一个子网划分为更小的子网
[回到顶部](#menu)