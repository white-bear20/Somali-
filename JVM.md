## JVM虚拟机类加载机制

### 虚拟机的加载机制是什么?

虚拟机把描述类信息的数据从 .class 文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的JAVA类型，JAVA中类型的加载，连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为JAVA应用程序提供高度的灵活性。

### 类在何时被加载

类被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期分为七大阶段:

![](E:\学习笔记\基本知识笔记\2.编程语言\8.JAVA\拓展知识\img\JVM类加载过程.png)

其中 加载--验证--准备--初始化--卸载,这个五个阶段的执行顺序是确定的，解析阶段是不确定的，在某些情况下它可以在初始化阶段之后再开始，这是为了支持JAVA语言的运行时绑定(动态绑定或晚期绑定)，这些阶段通常都是相互的交叉地混合式进行的，通常会在一个阶段执行的过程中调用，激活另外一个阶段



#### 什么时候会执行第一个阶段(加载)

JAVA虚拟机规范中并没有强制性的约束什么时候对类进行加载，这点可以交给虚拟机的具体实现来自由把握



##### **但是对于初始化阶段是有强制要求的，所以加载肯定会在它之前被执行**



#### 必须立即对类进行初始化的五大情况

* 遇到new,getstatic,putstatic,invokestatic这四条指令码时，如果没有对类进行初始化，则需要先进行初始化
  * 用new实例化对象时
  * 读取或设置一个静态字段时(被final修饰的除外，因为它在编译器就已经被放入常量池了)
  * 调用一个类的静态方法时
  * 简单记就是被new了或者调用了被static修饰的方法或属性就会被初始化(被final修饰的除外)
* 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有被初始化，则会先进行初始化
* 当初始化一个类的还是，如果发现父类还没有被初始化， 就会先初始化父类
* 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类
* 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化

#### 三种情况下不会对类进行初始化

* 通过子类引用父类的静态字段或静态方法，不会初始化子类
* 通过数组定义来引用类，不会触发此类的初始化
* 被final修饰的变量

#### 类加载的过程

##### 加载

​	加载是类加载过的一个阶段，在加载阶段虚拟机需要完成三件事

* 通过一个类的全限定名来获取定义此类的二进制字节流
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

简单来说就是，把.class文件读入内存，转为运行时数据结构，映射为Class对象

##### 验证

​	为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，大致分为4个步骤

* 文件格式验证
* 元数据验证
* 字节码验证
* 符号引用验证

##### 准备

​	为类变量分配内存，并设置类变量初始值的阶段，这些变量锁使用的内存都将在方法区中进行分配

​	注意这时候分配的类变量的内存，也就是被static修饰的变量，而且看到存入方法区也应该知道是什么

​	这里设置的初始化值一般情况下并不是我们设置的值，而是对应数据类型的零值

| 数据类型  | 零值     |
| --------- | -------- |
| int       | 0        |
| long      | 0L       |
| short     | (short)0 |
| char      | '\u0000' |
| byte      | (byte)0  |
| boolean   | false    |
| float     | 0.0f     |
| double    | 0.0d     |
| reference | null     |

不一般的情况就是被final修饰的变量，被final修饰的变量的值会是我们所指定的值

##### 解析

解析阶段是虚拟机将常量池内的**符号引用**替换为**直接引用**的过程



**符号引用(Symbolic References)**,符号引用以一组符号来描述所引用的目标，符号可以任何形式的字面量，只要在使用时可以无歧义的定位到目标即可，符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中，各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中



**直接引用(Direct References)**,直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那么说明引用目标一定在内存中



##### 初始化

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

<clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。

由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

<clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。

接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。

虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的



接口和类的初始化过程有点不太一样

​	类一定会先指定父类的<clinit>()方法

​	接口可以只执行自己的<clinit>()方法，除非调用了父类接口中定义的变量

### 类加载器

类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

这里所指的“相等”，包括代表类的Class对象的equals()方法、 isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果

#### JAVA中的三大类加载器

* 启动类加载器(Bootstrap ClassLoader)
  * 这个类加载器将负责存放在<JAVA_HOME>\lib目录中或者被-Xbootclasspath参数所指定的路径中，并且是虚拟机识别(按照文件名识别)的类库加载到虚拟机内存中
* 扩展类加载器(Extension ClassLoader)
  * 个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器
* 应用程序类加载器(Application ClassLoader)
  * 这个类加载器由sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器

##### 双亲委派模型

![alt 双亲委派模型](E:\学习笔记\基本知识笔记\2.编程语言\8.JAVA\拓展知识\img\双亲委派模型.png)

图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码



**工作流程**

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱

## JVM内存区域

### 运行时数据区（JVM运行时会把内存划分为如下区域）

![alt 内存区域图](E:\学习笔记\基本知识笔记\2.编程语言\8.JAVA\拓展知识\img\JVM内存区域.png)

```
JAVA虚拟机在执行JAVA程序的过程中，会把它所管理的内存分成如上区域(JAVASE 7版的JAVA虚拟机规范)

各个区域，有各自的用途，创建，销毁时间(有的随虚拟机启动而存在，有的依赖用户线程的启动和结束而建立和销毁)
```

### 程序计数器

它是一小块内存区域，**线程私有**,其**作用**在于**记录当前线程所指定到的字节码指令的地址**，如果执行的Native方法的话，它的值为0，这块区域是**唯一**一个在JAVA虚拟机规范中没有规定任何**OutOfMemoryError**情况的区域

### 虚拟机栈

**线程私有**，生命周期与线程相同，虚拟机栈**描述**的是JAVA方法**执行**的**内存模型**,**每个方法**在执行的同时都会**创建一个栈帧**用于存储

* 局部变量表
* 操作数栈
* 动态连接
* 方法出口

每一个方法从调用到执行完成的过程，就对应这一个栈帧在虚拟机栈中入栈到出栈的过程

```
局部变量表:
	存储了编译器可知的各种数据类型，对象引用(reference类型)
	long和double等64位长度的数据类型会占用2个局部变量空间(Slot),其他的则占用一个(Slot=4byte?)
	局部变量表所需的内存空间在编译器期间就会完成分配，这个大小是完全确定的不会在运行时改变
	
	reference:
		它不等同与对象本身，可能是一个指定对象的起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置
		
	这个区域规定了两种异常状态:
		StackOverflowError(线程请求的栈深度大于虚拟机所允许的深度)
		OutOfMemeoryError(虚拟机栈可以动态扩展，但是扩展时无法申请到足够的内存)
```

### 本地方法栈

和虚拟机栈发挥的作用类似，不过只是使用它的对象是Native方法

### 堆

这是JVM所管理的最大一块内存，这块区域是**线程共享**的,在虚拟机启动时就会创建，它的**唯一目的**就是**存储对象实例**,几乎所有的对象实例都在这里分配内存

java堆是垃圾收集器管理的主要区域，因此也被称为**GC堆**

根据JAVA虚拟机规范的规定，JAVA堆可以处理物理上不连续的内存空间中，只要逻辑上连续即可，如果在堆没有内存完成实例分配时，并且堆也无法在拓展时，会抛出OutOfMemoryError异常

### 方法区

**线程共享区域**,它用于**存储**已被**虚拟机加载**的

* 类信息
* 常量
* 静态变量
* 即时编译后的代码
* ...



方法区是一个概念，它具体放在哪里，不同的实现可以放在不同的地方



根据JAVA虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常



#### 运行时常量池

```
这个也是方法区的一部分，class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期间生产的各种字面量和符号引用，这部分内存将在类加载后进入方法区的运行时常量池中存放

一般来说，除了保存class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中
当常量池无法在申请到内存时会抛出OutOfMemoryError异常
```

